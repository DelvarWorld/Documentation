nd second sphere (balloon) will collide on the rotated ground, the last one will be in collision only on a single point. Once you have created this basic scene, continue reading to learn how to check collisions."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"* **Intersect mesh**"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"The point here is to check contact between our balloons and the ground. We will use the “intersectsMesh()” function, with two parameters: the mesh to be checked, and the precision of the intersection (boolean)."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"```javascript"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"if (balloon1.intersectsMesh(plan1, false)) {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"To perform this magic trick, the first thing to do is to create a new object, which will be the particle emitter. In our case, a box will be our emitting object, representing a particle fountain."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"var fountain = BABYLON.Mesh.CreateBox(\"fountain\", 1.0, scene);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The emitter acts as the source of the particles, and its location in 3D space determines where they are generated and how they move. So pay attention to the location/rotation of this object."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"In our case, the emitter is our fountain, but if you wish, you can use only a vector (BABYLON.Vector3) as an emitter."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Now, we must create a new (not-rendered) ParticleSystem object:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"We will talk about that nice fog effect, shortly.&nbsp; First, I want to introduce you to two interesting properties on the [scene class object](http://doc.babylonjs.com/page.php?p=24894):"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"* `scene.clearColor` - changes the 'background' color."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"* `scene.ambientColor` - changes the color used in several effects, including ambient lighting."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Both of them are very useful, and powerful in their own right."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"### Changing the Background color (`scene.clearColor`)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"The 'clearColor' property on the scene object is the most rudimentary of environment properties/adjustments. Simply stated, this is how you change the background color of the scene.&nbsp; Here is how it is done:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* **Introduction**"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Those mountains are very easy to generate with Babylon.js, and with only a single function. But before we do that, we have to create a new material, like we have done many times before:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```javascript"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"var groundMaterial = new BABYLON.StandardMaterial(\"ground\", scene);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"groundMaterial.diffuseTexture = new BABYLON.Texture(\"Earth__land.jpg\", scene);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"var groundPlane = BABYLON.Mesh.CreatePlane(\"groundPlane\", 200.0, scene);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"groundPlane.material = groundMaterial;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Shadows are easy to generate using the babylon.js “ShadowGenerator”. This function uses a shadow map: a map of your scene generated from the light’s point of view, as you can see here:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"![Shadows2](http://www.babylonjs.com/tutorials/15%20-%20Shadows/15-1.png)"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"The two parameters used by the shadow generator are: the size of the shadow map, and which light is used for the shadow map's computation."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Next, you have to define which shadows will be rendered. Here we want the shadow of our torus, but you can “push” any meshes you want:"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Well, I'm about to talk about atlases here, but remember it's only an example to illustrate the per-texture feature. It's not mandatory to use an atlas, we can just use a regular texture file and choose what part of it to display on each (or only some) box face.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Let's start..."},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"We create a rectangular box by using the _options_ parameters line 43 and 50 : http://www.babylonjs-playground.com/#1V3CAT  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"###Fixed Shapes"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"We call _fixed shapes_ all the mesh types that are not parametric, it is to say all the mesh types what have an expected final shape.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"For instance, if we create a _Sphere_ or a _Box_ mesh, we expect to get a spherical or a cubic shape whereas if we create a _Ribbon_ mesh, as it depends upon a data set to be created (the _pathArray_), we can't predict its final shape.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"All fixed shapes can be created by default by using a blank _options_ parameter :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var cylinder = BABYLON.Mesh.CreateCylinder(\"cyl\", {}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"This means all the _options_ properties are simply optional.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Box"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"![Ribbon](http://jerome.bousquie.fr/BJS/images/ribbon.png)"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"CreateRibbon(name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation);"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **name** : string."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **pathArray** : an array of paths.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"As explained in the [Basic Elements](02. Discover Basic Elements) section, the ribbon is the surface between two, or more, paths.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"A path is a series of successive points in space (Vector3).  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"So a path can be designed by many ways : you can set points manually, import them from some set of data (json, etc), compute them with some maths function ... or even a bit of all of this.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"There is also no incidence on light reflection for ribbon with different length paths : http://www.babylonjs-playground.com/#88AZQ#1  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Therefore you **can't add a texture** for now to a ribbon constructed with different length paths.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"This is due to the fact that the nested ribbon texturing algorithm only knows how to deal with a unique length for all paths. Indeed, as a ribbon is a parametric shape, so unpredictable, it's assumed that we could unwrap a volumic ribbon (so each one of its paths) onto a full rectangular image and this assumption keeps consistency only with the same length for all paths.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So it's not mandatory that all the ribbon paths have the same length, but it is hardly recommended.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The best way to emulate different lengths for some parts of your mesh is then to simply use many ribbons.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"## Closed shapes : normals or textures ?   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The ribbon mesh provides two ways to automatically close an unclosed shape."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* _closeArray_ parameter : this will add an extra unit ribbon between the last path and the first path of your _pathArray_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* _closePath_ parameter : this will join the last and first points of each _path_ in your _pathArray_.  "},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"fFogDistance = (view * worldPosition).z; // This is the distance of the vertex from the point of view of the camera (Camera space)"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"##Pixel shader"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"First you need to add the following code to be able to compute the fog accordingly to parameters sent by the scene:"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"#define FOGMODE_NONE 0."},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"#define FOGMODE_EXP 1."},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"#define FOGMODE_EXP2 2."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <body>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   </body>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</html>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"### The CSS Style Part"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Inside the ```<head>``` part, please add this CSS to view the canvas in maximum size:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```css"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<style>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  html, body {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    overflow: hidden;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    width: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    height: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    margin: 0;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    padding: 0;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  }"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        camera.attachControl(canvas, false);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var light = new BABYLON.HemisphericLight(\"hemi\", new BABYLON.Vector3(0, 1, 0), scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //Creation of a box"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //(name of the box, size, scene)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var box = BABYLON.Mesh.CreateBox(\"box\", 6.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //Creation of a sphere "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //(name of the sphere, segments, diameter, scene) "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var sphere = BABYLON.Mesh.CreateSphere(\"sphere\", 10.0, 10.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //Creation of a plane"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //(name of the plane, size, scene)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var plane = BABYLON.Mesh.CreatePlane(\"plane\", 10.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //Creation of a cylinder"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"[…]"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"    //Positioning the meshes"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"    sphere1.position.x = -40;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"    sphere2.position.x = -30;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"So far, you only have some grey-colored meshes. How drab! To apply a material to them, you will need to create a new material object like this:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"var materialSphere1 = new BABYLON.StandardMaterial(\"texture1\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"And apply this material to the object of your choice, e.g.:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"sphere1.material = materialSphere1;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Or, create and apply all in one step:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"sphere1.material = new BABYLON.StandardMaterial(\"texture1\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"Here is how you construct our handy ArcRotateCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// ArcRotateCamera >> Camera turning around a 3D point (here Vector zero) with mouse and cursor keys"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, alpha, beta, radius, target, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   var camera = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The ArcRotateCamera is a little strange to use, at first, but in no time, you will be using them often and easily. There are three unique properties on the ArcRotateCamera which are named _alpha_ (in radians), _beta_ (in radians), and _radius_ (a number). If you imagine an ArcRotateCamera being a satellite orbiting the Earth, then the _alpha_ is the longitudinal or sideways axis, the _beta_ is the latitudinal or up/down axis, and the _radius_ is the altitude or height (distance) from the Earth's core. Here is an illustration:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"![](http://urbanproductions.com/wingy/babylon/misc/arc01.jpg)"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The ArcRotateCamera has many properties that you can use to adjust your view. Some of the most commonly used properties are _alpha_, _beta_, _radius_, _target_, _speed_, _inertia_, and _fov_."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"By default, (with no .alpha and .beta values set), ArcRotateCameras aim in a +x direction. Ironically, there is no rotation property on an ArcRotateCamera, but there is a position property. Because the orientation of an ArcRotateCamera is relative to its _target_ setting, it is wise to use a handy method called _setPosition()_ to set the camera position."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"In the example below, we will construct an ArcRotateCamera with a target of 'Zero()' and no initial _alpha_, _beta_, or _radius_ values. (Be warned: A zeroed-out ArcRotateCamera aims in a strange way until _setPosition()_ is called). Then we will use the setPosition() function with a common Vector3 position value... to set our _alpha_, _beta_, and _radius_ values all at once, automatically:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"A point light is a light defined by an unique point in world space. The light is emitted in every direction from this point. A good example of a point light is the sun."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"You can control the color of any light... with the *diffuse* and *specular* properties:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.PointLight(\"Omni0\", new BABYLON.Vector3(1, 10, 1), scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.diffuse = new BABYLON.Color3(1, 0, 0);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.specular = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-44-73-metablogapi/8484.image_5F00_thumb_5F00_53D78E00.png)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"_Red diffuse point light with white specular_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"- **The Directional Light**"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;//Create a box"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;var box1 = BABYLON.Mesh.CreateBox(\"Box1\", 10.0, scene);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;box1.position.x = -20;"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Our goal: move this “box1”. First, create our Animation object:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var animationBox = new BABYLON.Animation(\"myAnimation\", \"scaling.x\", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Much information is in the parameters:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Parameter 1 - Name of this animation, nothing more."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Parameter 2 - The property concerned. This can be any mesh property, depending upon what you want to change. Here we want to scale an object on the X axis, so it will be “scaling.x”."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Parameter 3 - Frames per second requested: highest FPS possible in this animation."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"When creating a sprite manager, you have to decide a few parameters:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"* Name: a name for this manager."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"* The 2D image URL (most of the time, you will want use an image format which contain alpha channel, like .PNG)."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"* The capacity of this manager : the maximum number of instances in this manager (in our example, we could create 2000 instances of trees)."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"* The cell size, corresponding to the size of your image, like we’ll see below."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"* The actual scene, to which we will add this manager."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"To give another example, look at this snippet:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"var spriteManagerPlayer = new BABYLON.SpriteManager(\"playerManagr\",\"Assets/Player.png\", 2, 64, scene);"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"This time, we only want 2 instances, and we said that our sprite’s size is 64. Here is what our image looks like:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"![Elements](http://www.babylonjs.com/tutorials/08%20-%20Sprites/08-1.png)"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Each image of a sprite must be contained in a 64 pixel square, no more no less."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"**2 - Define an ellipsoid**"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"The next important step is to define the ellipsoid around our camera. This ellipsoid represents our player’s dimensions: a collision event will be raised when a mesh comes in contact with this ellipsoid, preventing our camera from getting too close to this mesh:"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"![Ellipsoid](https://camo.githubusercontent.com/19931f529e19679a0e2556e23fc94536e6a9b88c/687474703a2f2f7777772e626162796c6f6e6a732e636f6d2f7475746f7269616c732f30392532302d253230436f6c6c6973696f6e73253230477261766974792f30392d312e6a7067)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"The _ellipsoid_ property on babylon.js cameras is default to size (0.5, 1, 0.5), but changing values will make you taller, bigger, smaller, thinner, it depends upon the adjusted axis. In the example below, we will make our camera's ellipsoid a bit bigger than the default one:"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"//Set the ellipsoid around the camera (e.g. your player's size)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"**3 - Apply collision**"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"Once you have those previous settings completed, our final step is to declare that we are interested in sensing collisions in our scene:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"   var pickResult = scene.pick(scene.pointerX, scene.pointerY);"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"}),"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"```"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":" "},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"The pickResult object is mainly composed of 4 pieces of information:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"1. _hit_ (bool): « True » if your click hits an object in the scene."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"1. _distance_ (float): the “distance” between the active camera and your hit (infinite if no mesh was hit)"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"1. _pickedMesh_ (BABYLON.Mesh): if you hit an object, this is the selected mesh. If not, it’s null."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"1. _pickedPoint_ (BABYLON.Vector3): the point you have clicked, transformed in 3D coordinates, depending on the object you’ve clicked. Null if no hit."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Now we have all the data we need to build our scene. We just have to position our gun’s impact picture (a plane made earlier... called impact) when the user clicks on the wall plane:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"```javascript"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"// if the click hits the wall object, we change the impact picture position"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"if (pickResult.hit) {"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"            impact.position.x = pickResult.pickedPoint.x;"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"            impact.position.y = pickResult.pickedPoint.y;"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"&nbsp;&nbsp; balloon1.material.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"} else {"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"&nbsp;&nbsp; balloon1.material.emissiveColor = new BABYLON.Color4(1, 1, 1, 1);"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"}"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"```"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"To avoid costly calculation by checking many details on a mesh, Babylon engine creates a bounding box around the object, and tests for intersection between this box, and the colliding mesh. Here is an example of a bounding box:"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"![Collisions](http://www.babylonjs.com/tutorials/10%20-%20Collisions%20Intersect/10-1.png)"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"But this bounding box can be more or less precise, and that’s why we have our second parameter. In short, if this parameter is set to true (false by default), then the bounding box is closer to the mesh (OBB bounding type), but it’s a more costly calculation. Be aware that this type of bounding box is especially useful when your mesh is rotated to an angle."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"![Collisions](http://www.babylonjs.com/tutorials/10%20-%20Collisions%20Intersect/10-2.png)"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"So think about the collisions details you need before to choose."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"var particleSystem = new BABYLON.ParticleSystem(\"particles\", 2000, scene, customEffect);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        Simple. The first parameter is the name, he second parameter is the maximum number of particles, the third parameter is the scene, and the optional fourth parameter is a reference to a shader effect for the particles, overriding the default shader. I will talk about the fourth parameter further below."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    An important part is to define the texture of each particle. Each one will have the same pattern, so choose carefully which one you want. But keep in mind that a single scene can contain multiple particleSystems, and each one can emit particles with unique texture patterns. Also keep in mind that multiple particle systems can use the same emitter object. "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Our particle texture is going to be this one:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"![Flare](http://www.babylonjs.com/tutorials/12%20-%20Particles/Flare.png)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"To define the particle’s texture, add a line like this:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.particleTexture = new BABYLON.Texture(\"Flare.png\", scene);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Or maybe you want to use one of our preset colors and avoid using the `new` keyword:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.clearColor = BABYLON.Color3.Blue();"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"This color and property is not used in any calculations for the final colors of mesh, materials, textures, or anything else. It is simply the background color of the scene.&nbsp; Easy."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"### Changing the Ambient color (`scene.ambientColor`)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Conversely, the `ambientColor` property on the scene object is a very powerful and influential environment property/adjustment.&nbsp; First, let's have a look at its syntax:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"![HeightMap2](http://www.babylonjs.com/tutorials/14%20-%20Height%20map/14-1.png)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"_Our material, a texture, applied to the plane_"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* **Explanations of a height map**"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Understanding height maps is the main objective of this tutorial. A height map is simply a greyscale image like the one we are going to use:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"![HeightMap3](http://www.babylonjs.com/tutorials/14%20-%20Height%20map/worldHeightMap.jpg)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"This image will now be used to generate our ground, using the different variants of gray of our picture. This image is the elevation data for your ground. Each pixel’s color is interpreted as a distance of displacement or “height” from the “floor” of your mesh. So, the whiter the pixel is, the taller your mountain will be."},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"To help you generate those gray-scale height maps, you can use software such as “Terragen”, or ”Picogen”. "},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* **Javascript code**"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript "},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"shadowGenerator.getShadowMap().renderList.push(torus);"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"And finally, you will have to define where the shadows will be displayed... by setting a mesh parameter to true:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"ground.receiveShadows = true;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"You may want to reduce shadow acne resulting from not precise enough shadow map. To do so, you can define the bias (which is 0.00005 by default).:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"shadowGenerator.bias = 0.01;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"## Filters"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"If you want to go further, you can activate shadows filtering."},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Then we set the texture as a value on a material as usual : http://www.babylonjs-playground.com/#1V3CAT#1  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Nothing new until now, right ?  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Let's go on."},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Please let's have a look from line 27 :  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Line 30, we define a new array called _faceUV_, sized 6 because our box has 6 faces. This array will always content Vector4 elements.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Each _Vector4(x, y, z, w)_ will be defined in this way :  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var box = BABYLON.Mesh.CreateBox(\"box\", {height: 5, faceColors: myColors}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"size|_(number)_ size of each box side|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"height|_(number)_ height size, overwrites _size_ property|size"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"width|_(number)_ width size, overwrites _size_ property|size"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"length|_(number)_ length size,  overwrites _size_ property|size "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"faceColors|_(Color4[])_ array of 6 _Color4_, one per box face|Color4(1, 1, 1, 1) for each side"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"faceUV|_(Vector4[])_ array of 6 _Vector4_, one per box face| UVs(0, 0, 1, 1) for each side"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Sphere"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var sphere = BABYLON.Mesh.CreateSphere(\"sphere\", {diameter: 2, diameterX: 3}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"segments|_(number)_ number of horizontal segments|32"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"The javascript representation of a path is simply an array of Vector3.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"A path must have at least two points (four points if you provide a single path). "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"In order to create a ribbon, you just have to pass an array of paths. This array can contain only one path and in this case, the _offset_ parameter is used. "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **closeArray** : _default False_  boolean, if true an extra set of triangles is constructed between the last path and the first path of pathArray."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"example : http://www.babylonjs-playground.com/#295H7U  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here we populate an array called _paths_ with many path arrays.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Each _path_ array is populated itself with Vector3 along a Bézier curve. Anything else could have been chosen for this example, but I love this strange shape.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Before dealing with the ribbon, we just display each path with the _CreateLines()_ method so we can figure out what these paths look like. As we can see, the curves are side by side around an incomplete circle.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we apply this _paths_ array to a ribbon mesh, we get this : http://www.babylonjs-playground.com/#295H7U#1  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"You can see that a surface is constructed between each _path_ as expected.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is the same with a plain material ans still the _paths_ displayed : http://www.babylonjs-playground.com/#295H7U#2  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we set _closeArray_ to _true_, the missing surface between the first and the last _paths_ is then constructed : http://www.babylonjs-playground.com/#295H7U#3  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"The mesh becomes then a real closed volume and the light reflects in a continuous way along its surface.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **closePath** : _default False_ boolean, if true the last point of each path of _pathArray_ is joined to the first point of this same path.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"example : http://www.babylonjs-playground.com/#1TDTHJ  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is some kind of unclosed tubular ribbon. "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Here's an unclosed ribbon : http://www.babylonjs-playground.com/#3XMWZ#1"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", paths, false, false, 0, scene, false, BABYLON.Mesh.BACKSIDE);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Don't mind about how it is mathematically built. This is not the topic.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The same closed ribbon with _closeArray_ set to _true_ : http://www.babylonjs-playground.com/#3XMWZ#2"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", paths, true, false, 0, scene, false, BABYLON.Mesh.BACKSIDE);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"As you can see, when rotating the camera, there is no edge on the ribbon surface. The light reflects continuously.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"If we now apply a texture to this automatically closed ribbon : http://www.babylonjs-playground.com/#3XMWZ#3  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You can notice that the texture isn't stretched on the surface added by the automatic closing.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The reason of this behavior is that, with ribbon _closeXXX_ parameters, priority is given on normals (the tools that compute light reflection) over textures.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"If you don't care about continuous light reflection but you do want your texture to be stretched along the whole surface, you just have to forget automatic closing (_closeArray_ then set to _false_) and close the ribbon by yourself.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"A simple way is just to re-push the first _path_ at the end of the _pathArray_"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"paths.push(paths[0]);"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"#define FOGMODE_LINEAR 3."},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"#define E 2.71828"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"uniform vec4 vFogInfos;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"uniform vec3 vFogColor;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"varying float fFogDistance;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"float CalcFogFactor()"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"{"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" float fogCoeff = 1.0;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" float fogStart = vFogInfos.y;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" float fogEnd = vFogInfos.z;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" float fogDensity = vFogInfos.w;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" if (FOGMODE_LINEAR == vFogInfos.x)"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" {"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"  fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" }"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" else if (FOGMODE_EXP == vFogInfos.x)"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" {"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"  fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  #renderCanvas {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    width: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    height: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    touch-action: none;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  }"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</style>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"### The Javascript External Includes Part (the framework)"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Now we load our framework files.  After the CSS, (but still inside the ```<head>``` part), please add:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```html"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<script src=\"babylon.js\"></script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<script src=\"hand.js\"></script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<script src=\"cannon.js\"></script>  <!-- optional physics engine -->"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<!-- <script src=\"Oimo.js\"></script>  New physics engine -->"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"(if you don't already have those files, you can find them here: https://github.com/BabylonJS/Babylon.js, and here: http://handjs.codeplex.com/)"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Next, we go inside the ```<body>``` part of the web page... and add a HTML5 canvas element, which will be used to draw our scene."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```html"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<canvas id=\"renderCanvas\"></canvas>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Now, we make the jump from HTML5 into Javascript.  Still inside the ```<body>``` part of the web page,  please add:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```javascript"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // Get the canvas element from our HTML above"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        //(name, height, diamTop, diamBottom, tessellation, [optional height subdivs], scene, updatable)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var cylinder = BABYLON.Mesh.CreateCylinder(\"cylinder\", 3, 3, 3, 6, 1, scene, false);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // Creation of a torus"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // (name, diameter, thickness, tessellation, scene, updatable)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var torus = BABYLON.Mesh.CreateTorus(\"torus\", 5, 1, 10, scene, false);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // Creation of a knot"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var knot = BABYLON.Mesh.CreateTorusKnot(\"knot\", 2, 0.5, 128, 64, 2, 3, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // Creation of a lines mesh"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        var lines = BABYLON.Mesh.CreateLines(\"lines\", ["},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"            new BABYLON.Vector3(-10, 0, 0),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"            new BABYLON.Vector3(10, 0, 0),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"            new BABYLON.Vector3(0, 0, -10),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"            new BABYLON.Vector3(0, 0, 10)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        ], scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        // Moving elements"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        box.position = new BABYLON.Vector3(-10, 0, 0);   // Using a vector"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        sphere.position = new BABYLON.Vector3(0, 10, 0); // Using a vector"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        plane.position.z = 10;                  // Using a single coordinate component"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        cylinder.position.z = -10;"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        torus.position.x = 10;"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        knot.position.y = -10;"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"        return scene;"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    }"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Starting with the box, we create 7 different basic elements, and then position them at the end of the function (to keep them from being atop one another).  It's really quite easy, isn't it?  Again, starting with the creation of the box, let's talk about each of the 7 shapes/meshes.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Box**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var box = BABYLON.Mesh.CreateBox(\"box\", 6.0, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"“I tested my scene, and …nothing changed…”"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Exactly, because this material is the default one. You have to customize it as you like. You won’t change the mesh itself, but just the material."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"“So how can I adjust my material to give the perfect look to my object?”"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"That is done by setting the properties on the material.  Let's see what they are:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Transparency** (alpha channel)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Alpha compositing and transparency in general can be a bit complex. A specific article about that can be found [here](page.php?p=25100). You might also want to read [the wikipedia page about it](http://en.wikipedia.org/wiki/Alpha_compositing).  You will encounter even more uses for it when you enjoy the BabylonJS particle system, and BabylonJS sprites system. "},{"src":"tutorials/04._Materials","name":"04. Materials","text":" Alpha transparency, written in percent (%), can be applied to a material in this way:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.alpha = 0.5;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Diffuse**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"The diffuse is the native color of the object material once it is lit with a light. You can specify a solid color with the ```diffuseColor``` property:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseColor = new BABYLON.Color3(1.0, 0.2, 0.7);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Or, you can use a texture:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture = new BABYLON.Texture(\"grass.png\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"![tof](http://www.babylonjs.com/tutorials/04%20-%20Materials/04-1.png)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"**More About Textures:** Be sure to use the correct path to your image (relative or absolute path). Supported image formats include JPG, PNG, JPEG, BMP, GIF… (every image format supported by your browser)."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"If you want to translate (offset) your texture on your mesh, you can use the “uOffset” and “vOffset” properties:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture.uOffset = 1.5;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture.vOffset = 0.5;"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   // Create an ArcRotateCamera aimed at 0,0,0, with no alpha, beta or radius, so be careful. It will look broken."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   var camera = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 0, 0, 0, BABYLON.Vector3.Zero(), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   // Quick, let's use the setPosition() method... with a common Vector3 position, to make our camera better aimed."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   camera.setPosition(new BABYLON.Vector3(0, 15, -30));"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"When we use that useful _setPosition()_ method, we need not concern ourselves with _alpha_, _beta_, and _radius_. We just make sure we have a _target_ property set ( which we did in the constructor with new BABYLON.Vector3.Zero() ), and then use _setPosition()_ to put our camera exactly where we want it, in 3D space. The handy _setPosition()_ method does the rest. Easy."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The ArcRotateCamera is an excellent camera to animate. By default, the ArcRotateCamera has no _upperAlphaLimit_ or _lowerAlphaLimit_. So once you have set your arcCamera as the scene.activeCamera (see further below), you can send your ArcRotateCamera gently orbiting around your target... by putting this simple line of Javascript into the render loop of your scene:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   scene.activeCamera.alpha += .01;"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"It's beautiful, it's easy, it's Babylon.js. Please see the  [ArcRotateCamera API page](http://doc.babylonjs.com/page.php?p=23874) for more information."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"Both of these basic Babylon.js cameras will automatically handle inputs for you... once you call the camera's _attachControl_ function. And you can revoke the control by using the _detachControl_ function. Most Babylon.js experts use a two-step process to activate and attach a camera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// First, set the scene's activeCamera... to be YOUR camera."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   scene.activeCamera = myCamera;"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Then attach the activeCamera to the canvas."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   scene.activeCamera.attachControl(canvas);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"This activate-and-attach code is also used for our unique purpose cameras, which we will now talk about."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"## Unique Purpose Cameras"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"There are some Babylon.js cameras that have unique purposes. I will try to explain their purposes as we examine each camera and their constructors."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"A directional light is defined by a direction (what a surprise!). The light is emitted from everywhere... toward a specific direction, and has an infinite range. By default, the directional light is created at origin (0,0,0) position. Like a point light, you can control the color of the light with the *diffuse* and *specular* properties:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.DirectionalLight(\"Dir0\", new BABYLON.Vector3(0, -1, 0), scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.diffuse = new BABYLON.Color3(1, 0, 0);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.specular = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-44-73-metablogapi/1563.image_5F00_1ECD8F81.png)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"_Red diffuse directional light with white specular_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"- **The Spot Light**"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"A spot light is defined by a position (2nd arg), a direction (3rd arg), an angle (4th arg), and an exponent (5th arg). These values define a cone of light starting from the position, emitting toward the direction. "},{"src":"tutorials/06._Lights","name":"06. Lights","text":"The angle defines the size (field of illumination) of the spotlight's conical beam (in radians), and the exponent defines the speed of the decay of the light with distance (the light's 'reach distance'). Just like the other lights, you can control the color of the light with the *diffuse* and *specular* properties:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-44-73-metablogapi/7723.image_5F00_thumb_5F00_11F5CA14.png)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"&nbsp;_A simple drawing showing the shape of a spot light_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.SpotLight(\"Spot0\", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), 0.8, 2, scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.diffuse = new BABYLON.Color3(1, 0, 0);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.specular = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Parameter 4 - Type of change. Here you decide and enter what kind of value will be modified: is it a float (e.g. a translation), a vector (e.g. a direction), or a quaternion. Exact values are:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_FLOAT```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_VECTOR2```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_VECTOR3```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_QUATERNION```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_MATRIX```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp; - ```BABYLON.Animation.ANIMATIONTYPE_COLOR3```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Parameter 5. Finally, you have to decide and enter the type of behavior this animation will take at its upper limit (e.g. will it continue on, will it begin again, will it stop at the last key value, etc.):"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"* Use previous values and increment it: ```BABYLON.Animation.ANIMATIONLOOPMODE_RELATIVE```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"* Restart from initial value: ```BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"* Keep their final value: ```BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Now that we have our Animation object, it is time to say how those values will be modified. In our case, we want to scale our box, but not in a linear way: it must be faster when it became larger, and slower when it became thinner. So:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// An array with all animation keys"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var keys = []; "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; //At the animation key 0, the value of scaling is \"1\""},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;keys.push({"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; frame: 0,"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; value: 1"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;});"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;//At the animation key 20, the value of scaling is \"0.2\""},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;keys.push({"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"2- **Create an instance**"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Now that we have our manager, we can create instances of our sprite linked to this manager. Creating an instance is as simple as:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"var player = new BABYLON.Sprite(\"player\", spriteManagerPlayer);"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Voilà, you have got your sprite displayed!"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"If you want to add parameters to this instance, you can manipulate it like any other meshes:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.position.y = -0.3;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"But because it’s a sprite, you may use specific parameters: you can change their size, or their orientation:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.size = 0.3;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.angle = Math.PI/4;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.invertU = -1;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Starting with Babylon.js v2.1, you can define sprite's width and height:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.width = 0.3;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.height = 0.4;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"You can keep using ```player.size``` and in this case width and height will just be the same."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"// Enable Collisions"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"scene.collisionsEnabled = true;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"camera.checkCollisions = true;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"And declare which meshes could be in collision with our camera:"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"ground.checkCollisions = true;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"box.checkCollisions = true;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"That’s it! Easy!"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"You can play with the scene used in this tutorial... by visiting the Babylon.js [**playground demo**](http://www.babylonjs-playground.com/#4HUQQ)."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"Now, your camera is going to fall on the y-axis until it collides with the ground. And, your camera will collide with the box when you move it too near to it."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"**4 - Object vs. object collision**"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"You can also do the same thing with a mesh by playing with _mesh.ellipsoid_ property and _mesh.moveWithCollisions(velocity)_ function. This function will try to move the mesh according to given velocity and will check if there is no collision between current mesh and all meshes with checkCollisions activated."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"You can also use _mesh.ellipsoidOffset_ to move the ellipsoid on the mesh (By default the ellipsoid is centered on the mesh)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"var speedCharacter = 8;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"var gravity = 0.15;"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"var character = Your mesh;"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"}"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"```"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Fast, and easy, isn’t it?"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Feel free to play with this scene... [at our online playground](http://babylonjs-playground.azurewebsites.net/?11)."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"## Advanced Picking Features"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Please note that the pickResult object can provide you with additional information, detailed below:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- `faceId`: this is the position of the picked face's indices in the indices array. These can be accessed like so:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"```"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"var indices = pickResult.pickedMesh.getIndices();"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"var index0 = indices[pickResult.faceId * 3];"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"var index1 = indices[pickResult.faceId * 3 + 1];"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"var index2 = indices[pickResult.faceId * 3 + 2];"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"```"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- `submeshId`: the ID of the picked submesh inside the picked mesh"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- `bu` and `bv` properties: these are the barycentric coordinates of the picked point in the face. The picked face is a polygon composed of 3 vertices, and the picked point is the barycenter of those three vertices with the following weights:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"  * `1 - bu - bv` for the vertex n. 0"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"  * `bu` for the vertex n. 1"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"  * `bv` for the vertex n. 2"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- `getTextureCoordinates()`: computes the texture coordinates of the picked point; these will be returned as a `Vector2` in texture space, which means its coordinates will be between 0 and 1."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Possible uses include:"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- Drawing on a texture using a DynamicTexture,"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- Modifying a face that was hit (delete, move vertices, change color...),"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"If you want more information about this second parameter, you can have a look at this Wikipedia page, especially about AABB and OBB mode: [http://en.wikipedia.org/wiki/Bounding_volume](http://en.wikipedia.org/wiki/Bounding_volume)"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"* **Intersect point**"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"The other function you can use is “intersectsPoint()” with a specific point, like this:"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"```javascript"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"var pointToIntersect = new BABYLON.Vector3(10, -5, 0);"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"if (balloon3.intersectsPoint(pointToIntersect)){"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"&nbsp;&nbsp; balloon3.material.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"}"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"```"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"We defined a precise point in our scene, and if our balloon intersects this point, wherever on the balloon, then the event is raised and we change the color of the balloon."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"You can play with the code used in this tutorial... by visiting [**a demo at our playground**](http://babylonjs-playground.azurewebsites.net/?10)."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"## Next step"},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"With those two functions, your scenes are becoming a lot more dynamic: you can define a specific reaction to object intersecting and colliding, and begin to introduce physics notions into your scene."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"(in the playground demo, we used /textures/flare.png)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"For this texture, you can use an optional mask to filter some colors, or filter a part of the alpha channel."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.textureMask = new BABYLON.Color4(0.1, 0.8, 0.8, 1.0);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"This is the output of this configuration:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"![TextureMask](http://www.babylonjs.com/tutorials/12%20-%20Particles/12-1.png)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The last main thing to do is to define our emitter that we talked about earlier:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"// Where the particles comes from"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.emitter = fountain; // the starting object, the emitter, a box in this case."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Now you should see your particle system working. But it might not be our final result. We can refine some parameters:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Box around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.minEmitBox = new BABYLON.Vector3(-1, 0, 0); // Starting all From"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    particleSystem.maxEmitBox = new BABYLON.Vector3(1, 0, 0); // To..."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"As you can see, particles are emitted from different positions along the X-axis:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"![EmitBox](http://www.babylonjs.com/tutorials/12%20-%20Particles/12-2.png)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"As you can see, it is set using the same format as `clearColor`, but `ambientColor` is used in quite a few calculations toward determining the final colors of scene items.&nbsp; Mainly, it is used in conjunction with a mesh's `StandardMaterial.ambientColor` to determine a FINAL `ambientColor` for the mesh material. "},{"src":"tutorials/13._Environment","name":"13. Environment","text":"You will find that when there is no `scene.ambientColor`, then `StandardMaterial.ambientColor` and `StandardMaterial.ambientTexture` will appear to do nothing.&nbsp; Set a `scene.ambientColor` of some value, like the example above, and `StandardMaterial.ambientColor`/`StandardMaterial.ambientTexture` will become active on meshes where you have applied such."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"By default, `scene.ambientColor` is set to `Color3(0, 0, 0)`, which means there is no `scene.ambientColor`."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"(Please see the section on ambientColors in our [Unleash the Standard Material](http://blogs.msdn.com/b/eternalcoding/archive/2013/07/01/babylon-js-unleash-the-standardmaterial-for-your-babylon-js-game.aspx) tutorial, for more information.)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"### Skybox"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"To give a perfect illusion of a beautiful sunny sky, we are going to create a simple box, but with a special texture."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"![Skybox](http://www.babylonjs.com/tutorials/13%20-%20Environment/13-1.png)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"First, our box, nothing new, just take notice of the disabled [backface culling](http://en.wikipedia.org/wiki/Back-face_culling):"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"var skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 100.0, scene);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"var skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skyboxMaterial.backFaceCulling = false;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skybox.material = skyboxMaterial;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Next, we set the `infiniteDistance` property. This makes the skybox follow our camera's position."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skybox.infiniteDistance = true;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Now let’s see this powerful function named “CreateGroundFromHeightMap”:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```javascript"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"var ground = BABYLON.Mesh.CreateGroundFromHeightMap(\"ground\", \"worldHeightMap.jpg\", 200, 200, 250, 0, 10, scene, false, successCallback);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Many parameters here:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Name_"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Height map picture url_"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* Size of this mesh: "},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* > _Width_"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* > _Height_"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Number of subdivisions_: increase the complexity of this mesh in order to improve the visual quality of it:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"![HeightMap4](http://www.babylonjs.com/tutorials/14%20-%20Height%20map/14-2.png)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Minimum height_ : The lowest level of the mesh"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Maximum height_ : the highest level of the mesh"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Scene_: the actual scene"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* _Updatable_: indicates if this mesh can be updated dynamically in the future (Boolean)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* successCallback : will be called after the height map was created and the vertex data is created. It is a function with the mesh as its first variable."},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Finally, when our new mesh is ready, we simply apply our material:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```javascript"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"ground.material = groundMaterial;"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"There are three filters available:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"### Variance shadow map "},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"shadowGenerator.useVarianceShadowMap = true;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"It is _true_ by default, because it is useful to decrease the aliasing of the shadow.  But if you want to reduce computation time, feel free to change it."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"### Poisson sampling"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"shadowGenerator.usePoissonSampling = true;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"If you set this one to _true_, Variance shadow maps will be disabled. This filter uses Poisson sampling to soften shadows. The result is better, but slower."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"### Blur variance shadow map "},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```javascript"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"shadowGenerator.useBlurVarianceShadowMap = true;"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"This is the better soften shadow filter but the slower as well. It uses blurred variance shadow map."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"The quality of the blur is defined by two properties:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"* shadowGenerator.blurScale: Define the scale used to downscale the shadow map before applying the blur postprocess. By default, the value is 2"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"* shadowGenerator.blurBoxOffset: Define the offset of the box's edge used to apply the blur. By default, the value is 1 (Meaning the box will go from -1 to 1 in bot direction resulting in 9 values read by the blur postprocess)."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"### Examples"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Please find here pictures of various filters used with a spot light:"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"x = Utop  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"y = Vtop  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"z = Ubottom  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"w = Vbottom  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"all are in the range [0, 1]"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"as _Utop_, _Vtop_ are the 2D coordinates of the top left point of where the texture crop starts and _Ubottom_, _Vbottom_ the bottom right ones of where the texture crop ends.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Not clear ?  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Let's go back to our sprite atlas : we've got 4 rows of 6 sprites.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"So if we iterate i from 0 to 5 (so 6 times as 6 box faces) and if we assign  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Utop = i / 6"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Vtop = 0"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Ubottom = (i+1) / 6"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameter|_(number)_ diameter of the sphere|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameterX|_(number)_ diameter on X axis, overwrites _diameter_ property|diameter"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameterY|_(number)_ diameter on Y axis, overwrites _diameter_ property|diameter"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameterZ|_(number)_ diameter on Z axis, overwrites _diameter_ property|diameter"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Cylinder"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var cylinder = BABYLON.Mesh.CreateCylinder(\"cyl\", {diameterBottom: 0, tessellation: 4}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"height|_(number)_ height of the cylinder|2"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameterTop|_(number)_ diameter of the top cap, can be zero|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameterBottom|_(number)_ diameter of the bottom cap, can't be zero|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tessellation|_(number)_ number of radial sides|24"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"subdivisions|_(number)_ number of rings|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Plane"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var plane = BABYLON.Mesh.CreatePlane(\"plane\", {width: 5}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"size|_(number)_ side size of the plane|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"width|_(number)_ size of the width|size"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"height|_(number)_ size of the height|size"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Ground"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var ground = BABYLON.Mesh.CreateGround(\"gd\", {width: 6, subdivsions: 4}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"It is made with only two paths _path1_ and _path2_ each following an incomplete circle.   "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we set the _closePath_ to _true_ (http://www.babylonjs-playground.com/#1TDTHJ#1), you can notice that _path1_ and _path2_ are now closed and two triangles are added between the beginning and the end of each path.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we give this ribbon a plain material, you can then notice it is really closed as the normals are computed to reflect the light in a continuous way : http://www.babylonjs-playground.com/#1TDTHJ#2  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is the example of the former _closeArray_ parameter with _closeArray_ and _closePath_ set to true : http://www.babylonjs-playground.com/#295H7U#4  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **offset** : _default half size of the pathArray length_, mandatory only for pathArray containing a single path.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"example : http://www.babylonjs-playground.com/#1W5VJN#14"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is a single path _path1_, a simple helix. It is just shown with _CreateLines()_.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"We can populate the _pathArray_ with this single path : _[path1]_  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"In this case, the ribbon will be constructed by joining each point of the path to another point located _offset_ positions further in the path. Example : _offset = 10_, the point 1 will be joined to the point 11, the point 2 to the point 12, etc.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If you don't provide an _offset_ value, or if you provide a value greater than half of_path1 length, the _offset_ will be set by default to half of _path1_ length.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Back to our example : http://www.babylonjs-playground.com/#1W5VJN#15  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"_Offset_ is set to 20 here.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's change it to 5 : http://www.babylonjs-playground.com/#1W5VJN#16  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"So this parameter allows you to construct different meshes from a same single path.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"So playing with _offset_, _closeArray_, or other parameters, you can easily get volumic shapes, even with a single path : http://www.babylonjs-playground.com/#1W5VJN#17  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":" "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **updatable** : boolean, true if the ribbon could updated after creation"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":" "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **sideOrientation** : _default DEFAULTSIDE_"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  possible other values :  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"    * BABYLON.Mesh.FRONTSIDE"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"    * BABYLON.Mesh.BACKSIDE"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"    * BABYLON.Mesh.DOUBLESIDE  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"    see full explanation about _sideOrientation_ parameter in [**02-Basic elements**](http://doc.babylonjs.com/page.php?p=22011)"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If you need more details about ribbon uses, you might want to read the [Ribbon Tutorial]() part."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"## The Tube"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Basically a tube is just a curved (or not) cylinder.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"However it can be far more than just a cylinder if you consider it as a parametric shape.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Example with a simple cos/sin path :  http://www.babylonjs-playground.com/#LG3GS#8    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", paths, false, false, 0, scene, false, BABYLON.Mesh.BACKSIDE);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Example : http://www.babylonjs-playground.com/#3XMWZ#4  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Obviously, the same rules and workarounds apply to the _closePath_ parameter.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"automatically _path_ closed : http://www.babylonjs-playground.com/#3XMWZ#5  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"then textured : http://www.babylonjs-playground.com/#3XMWZ#6  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"## Maths computed paths"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The Ribbon is very adapted to elaborated maths computed meshes.    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You can easily start from an equation to get a full volumic complex shape.     "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"There are many ways to do it.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"If you don't feel at ease with maths, here is a way to start :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"### First, let's have a small recall.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"We just set points in space. These points have got each a set of three coordinates : x, y and z.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"We call here these points _Vector3_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"When we want to design a curve or a path in space, we need to get a collection of successive _Vector3_.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"We can't have an infinity of points.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So we define a path with a certain number of _Vector3_. The more _Vector3_, the more smooth the curve and the more computations too.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So when you want your path to follow a mathematical curve, you need to compute each path _Vector3_ coordinates.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You could choose a known math curve in wikipedia or dedicated sites (http://en.wikipedia.org/wiki/List_of_curves , http://www.mathcurve.com/courbes2d/courbes2d.shtml , http://www.uiowa.edu/~examserv/mathmatters/tutorial_quiz/geometry/commoncurves.html, etc) or, when you feel more comfortable, create you own.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"As you can see, curve equations are often like this : _f(x, y) = 0_ or like this : _y = f(x)_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"This means _y_ is expressed in function of _x_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"This kind of equation is called a _cartesian equation_. It is probably the most used among mathematicians, but it won't help us a lot because we need to compute _x_ and _y_ (and _z_) simultaneously to set each _Vector3_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So we will prefer the _parametric equations_.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"In a _parametric equation_ each different coordinate is defined in function of a parameter _k_ :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  _x = fct1(k)_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  _y = fct2(k)_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  _z = fct3(k)_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So if you are given a _cartesian equation_, it is quite almost possible to translate it in a _parametric equation_.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"example with a parabola : y =  x²   "},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" }"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" else if (FOGMODE_EXP2 == vFogInfos.x)"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" {"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"  fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" }"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":" return clamp(fogCoeff, 0.0, 1.0);"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"}"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"Then inside the shader you have to use this function to get the fog color:"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"float fog = CalcFogFactor();"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"##Javascript"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"You then have to add the following code for the onBind callback of your ShaderMaterial:"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"shaderMaterial.onBind = function(mat, mesh) {"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"    var effect = mat.getEffect();"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"    effect.setMatrix(\"view\", scene.getViewMatrix());"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"    effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity); "},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"    effect.setColor3(\"vFogColor\", scene.fogColor);"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"}"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  var canvas = document.getElementById(\"renderCanvas\");"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // Load the BABYLON 3D engine"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  var engine = new BABYLON.Engine(canvas, true);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"After this, you will add your scene creation code.  To keep your code compatible with the Babylon.js Playground, we recommend that you insert a 'createScene' function at this point.  Besides generating a Babylon Scene object, createScene() is where you will add your basic scene requirements:  One camera, one light, and one or more shapes/meshes."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"So now, add this entire createScene function to your web page:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":" "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```javascript"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // This begins the creation of a function that we will 'call' just after it's built"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  var createScene = function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Now create a basic Babylon Scene object "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    var scene = new BABYLON.Scene(engine);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Change the scene background color to green."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    scene.clearColor = new BABYLON.Color3(0, 1, 0);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // This creates and positions a free camera"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // This targets the camera to scene origin"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    camera.setTarget(BABYLON.Vector3.Zero());"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // This attaches the camera to the canvas"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    camera.attachControl(canvas, false);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"        "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // This creates a light, aiming 0,1,0 - to the sky."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    var light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Dim the light a small amount"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    light.intensity = .5;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Let's try our built-in 'sphere' shape. Params: name, subdivisions, size, scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    var sphere = BABYLON.Mesh.CreateSphere(\"sphere1\", 16, 2, scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Move the sphere upward 1/2 its height"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    sphere.position.y = 1;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Let's try our built-in 'ground' shape.  Params: name, width, depth, subdivisions, scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    var ground = BABYLON.Mesh.CreateGround(\"ground1\", 6, 6, 2, scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    // Leave this function"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    return scene;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  };  // End of createScene function"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Yes, that is quite a function, but do not let it scare you.  You will learn more about the parameters and properties for lights, cameras, and built-in shapes... in the tutorials to come.  The main thing to know is that our createScene function has all requirements complete.  It contains:  "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"*  a Babylon Scene object"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"*  a camera that has been attached"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"*  a light that has been aimed"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"*  a sphere that has been placed at position 0,1,0 (we moved it upward +y)"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"*  a ground plane that has been placed at position 0,0,0 (default position)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, size of the box, the scene to attach the mesh, updatable? (if the mesh must be modified later) and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var box = BABYLON.Mesh.CreateBox(\"box\", 6.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Sphere**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var sphere = BABYLON.Mesh.CreateSphere(\"sphere\", 10.0, 10.0, scene, false,  BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, number of segments (highly detailed or not), size, scene to attach the mesh, updatable? (if the mesh must be modified later) and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var sphere = BABYLON.Mesh.CreateSphere(\"sphere\", 10.0, 10.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Beware to adapt the number of segments to the size of your mesh ;)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Plane**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var plane = BABYLON.Mesh.CreatePlane(\"plane\", 10.0, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, size, and scene to attach the mesh, updatable? (if the mesh must be modified later) and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var plane = BABYLON.Mesh.CreatePlane(\"plane\", 10.0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Disc (or a regular polygon)**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var disc = BABYLON.Mesh.CreateDisc(\"disc\", 5, 30, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, radius, tessellation, scene, updatable and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var disc = BABYLON.Mesh.CreateDisc(\"disc\", 5, 30, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"With the  _tessellation_ value, you can get a regular polygon :  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"3 gives a triangle,  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"4 a square,  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"5 a pentagon,  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"6 a hexagon, 7 a heptagon, 8 an octogon, and so on."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Cylinder**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var cylinder = BABYLON.Mesh.CreateCylinder(\"cylinder\", 3, 3, 3, 6, 1, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, height, diamTop, diamBottom, tessellation, [height subdivs], scene, updatable and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var cylinder = BABYLON.Mesh.CreateCylinder(\"cylinder\", 3, 3, 3, 6, 1, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"The _height subdivs_ parameter (shown set to 1) is optional too."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Torus**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var torus = BABYLON.Mesh.CreateTorus(\"torus\", 5, 1, 10, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, diameter, thickness, tessellation (highly detailed or not), scene, updatable and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var torus = BABYLON.Mesh.CreateTorus(\"torus\", 5, 1, 10, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Knot**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var knot = BABYLON.Mesh.CreateTorusKnot(\"knot\", 2, 0.5, 128, 64, 2, 3, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable and the optional side orientation (see below). These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var knot = BABYLON.Mesh.CreateTorusKnot(\"knot\", 2, 0.5, 128, 64, 2, 3, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"You can learn more about torus knots... [**RIGHT HERE**](http://en.wikipedia.org/wiki/Torus_knot)."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"And if you want to repeat/tile an image pattern (e.g. grass texture), you can use the “uScale” and “vScale” properties:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture.uScale = 5.0;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture.vScale = 5.0;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Remember that (u, v) coordinates refer to the following axis:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"![tof](/img/tutorials/crate.jpg)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"And if your texture has some alpha, you will need to specify it:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.diffuseTexture.hasAlpha = true;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"In this case, alpha is used for alpha testing. But you may want to use it for alpha blending. To do so, just set ```materialSphere1.useAlphaFromDiffuseTexture```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"All of these texture settings apply to the other StandardMaterial properties as well. (.emissiveTexture, .ambientTexture, .specularTexture)  I will remind you.  Now let's continue talking about the other StandardMaterial properties."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Emissive**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"The emissive is the color produced by the object itself. You can specify a solid color with the ```emissiveColor``` property:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.emissiveColor = new BABYLON.Color3(1, .2, .7);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Or, you can use a texture:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.emissiveTexture = new BABYLON.Texture(\"grass.png\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"See the **More About Textures** section above.  Change occurrences of 'diffuse' to 'emissive', of course."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Ambient**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"The ambient can be seen as a second level of diffuse. The produced color is multiplied to the diffuse color. This is especially useful if you want to use light maps baked into textures. You can specify a solid color with the ```ambientColor``` property:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.ambientColor = new BABYLON.Color3(1, 0.2, 0.7);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Or, you can use a texture:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.ambientTexture = new BABYLON.Texture(\"grass.png\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"See the **More About Textures** section above.  Change occurrences of 'diffuse' to 'ambient', of course."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Specular**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"The specular is the color produced by a light reflecting from a surface. You can specify a solid color with the ```specularColor``` property:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.specularColor = new BABYLON.Color3(1.0, 0.2, 0.7);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Or, you can use a texture:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.specularTexture = new BABYLON.Texture(\"grass.png\", scene);"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"When using a texture you can set ```materialSphere1.useGlossinessFromSpecularMapAlpha``` to true to use specular map alpha as glossiness level."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"You can also control how specular behaves with alpha. By default, specular does not interact with alpha, but you can set ```materialSphere1.useSpecularOverAlpha``` to true to have alpha inversely proportional to specular value."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Again, see the **More About Textures** section far above.  Change occurrences of 'diffuse' to 'specular', of course."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **TouchCamera** - The TouchCamera is a camera that works closely with hand.js, and opens Babylon.js to the modern technology of DOM Gesture Events. Touch is a type a 'gesture', whether it be on a pad or screen, with finger(s), stylus, glove, feet, or laser pointer. Any movement that can be sensed... can be considered a gesture. You can learn all about gestures by visiting [**a wikipedia page that tells all about it**](http://en.wikipedia.org/wiki/Gesture_recognition)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The TouchCamera is specially programmed for nearly all modern gesture-active input devices. Much of its power comes from hand.js. If you would like to learn more about hand.js and its gestures-ready methods, take a look at [**this comprehensive blog entry**](http://blogs.msdn.com/b/eternalcoding/archive/2013/01/16/hand-js-a-polyfill-for-supporting-pointer-events-on-every-browser.aspx) written by our friend and hero David Catuhe."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"There is much underlying magic to the TouchCamera, but like everything else in Babylon.js, we make it easy and enjoyable for you. Here is how to construct a TouchCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// TouchCamera >> Move in your world with your touch-gesture device"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.TouchCamera(\"TouchCamera\", new BABYLON.Vector3(0, 1, -15), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The TouchCamera uses a FreeCamera as its basis, so all the powerful properties and methods of our familiar FreeCamera... are also found on our TouchCamera. You can explore all the properties and methods available on the TouchCamera... at [**our API documentation site**](http://doc.babylonjs.com/page.php?p=23886)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **DeviceOrientationCamera** - The DeviceOrientationCamera is a camera that is specifically designed to react-to device orientation events. Device orientation is when you tilt your modern mobile device forward or back, left or right, to control cameras or other scene items. And once again, our friend and technology guru David Catuhe has created [**a wonderfully-detailed blog entry**](http://blogs.msdn.com/b/eternalcoding/archive/2013/10/07/understanding-deviceorientation-events-by-creating-a-small-3d-game-with-babylon-js.aspx) to tell us all about it."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"Again, we we want it to be easy and enjoyable for you. Here is how you construct a Babylon.js DeviceOrientationCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// DeviceOrientationCamera >> Move in your scene with device orientation"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.DeviceOrientationCamera(\"DevOr_camera\", new BABYLON.Vector3(0, 1, -15), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The DeviceOrientationCamera also uses a FreeCamera as its basis, so all the powerful properties and methods of our familiar FreeCamera... are also found on our DeviceOrientationCamera. There are two rather important properties on the DeviceOrientationCamera: _angularSensibility_ and _moveSensibility_, which you can discover and explore... along with all of the other properties and methods... at [**our API documentation site**](http://doc.babylonjs.com/page.php?p=23880)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **FollowCamera** - Forum user AlexB was kind enough to contribute the handy FollowCamera to Babylon.js. (Thanks AlexB!) This camera is specifically designed to follow any scene item with a ._position_... as it moves. It can be set to follow from the rear, from the front, or from any angle. Its follow distance and movement speeds can be set, as well."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The constructor method we will show below... is from [Alex's FollowCamera forum thread](http://www.html5gamedevs.com/topic/8433-smooth-camera-follow/) and, as you can see, Alex makes it easy. Here is how you construct a Babylon.js FollowCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// FollowCamera >> Follow a mesh through your scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.FollowCamera(\"FollowCam\", new BABYLON.Vector3(0, 15, -45), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    camera.target = myMeshObject; // target any mesh or object with a \"position\" Vector3"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The code above... constructs the FollowCamera and adds a target mesh, which is all that is required. But the FollowCamera has some more useful properties that you can set if you choose to do so. Here's a few, with some example values:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"camera.radius = 30; // how far from the object to follow"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"camera.heightOffset = 8; // how high above the object to place the camera"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"camera.rotationOffset = 180; // the viewing angle"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"camera.cameraAcceleration = 0.05 // how fast to move"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"camera.maxCameraSpeed = 20 // speed limit"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"And don't forget to set:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"scene.activeCamera = camera;"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"There you have it. AlexB's cool FollowCamera. The FollowCamera is SO NEW, that we have not yet added it to our API documentation, but that will happen soon. We promise!"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **VirtualJoysticksCamera** - The VirtualJoysticksCamera is a camera that is specifically designed to react-to Virtual Joystick events. Virtual Joysticks are on-screen (canvas atop canvas) 2D graphics that are used to control cameras or other scene items. This time, another friend and hero of ours... David Rousset... takes us on [**a video tour with Virtual Joysticks**](https://www.youtube.com/watch?v=53Piiy71lB0), and makes it look easy. That is because it **is** easy. You can also [**read about Virtual Joysticks**](http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx) on David's blog."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-44-73-metablogapi/1738.image_5F00_thumb_5F00_18AB6448.png)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"_A red diffuse spot light with white specular, a 0.8 radians-wide cone, and an exponent of 2_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"- **The Hemispheric Light**"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"A hemispheric light is an easy way to simulate realistic ambient environment light. A hemispheric light is defined by a direction to the sky (the 2nd arg in the constructor) and by 3 colors: one for the diffuse (the sky color - for pixels/faces facing upward), one for the ground (the color for pixels/faces facing downward), and one for the specular."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Above, I used the terms 'upward' and 'downward', but keep in mind that the direction to the sky (the 2nd arg in the constructor) can be set to any direction. The direction to the sky is often straight upward (0, 1, 0). We are simulating light from a cloudy sky, but even on cloudy days, the sun crosses the sky above the clouds. So, you could tilt this light slightly toward the east for cloudy morning skies, and slightly toward the west for cloudy evening skies. This is a soft light that cannot produce shadows."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Now, back to creating the useful and interesting hemispheric light:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.HemisphericLight(\"Hemi0\", new BABYLON.Vector3(0, 1, 0), scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.diffuse = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.specular = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.groundColor = new BABYLON.Color3(0, 0, 0);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-44-73-metablogapi/4760.image_5F00_thumb_5F00_058CC84D.png)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"_White/black hemispheric light - upward pixels white (diffuse), downward pixels black (groundColor)_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Our [web site](http://www.babylonjs.com/) has a nice lights demo in the Features Tests section, and a similar lights demo can be found at our 'playground', [right here](http://www.babylonjs.com/playground/?06)."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"## Extra Information About Babylon.js One-Line Constructors: ##"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Here is an example of a one-line constructor:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.SpotLight(\"Spot0\", new BABYLON.Vector3(0, 30, -10), new BABYLON.Vector3(0, -1, 0), 0.8, 2, scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"That one-line is all it takes to create a spot light. We want Babylon.js scene item creation... to be as quick and simple as possible. We also want the scene item to be seen/operating with just one line of programming. The spot light is a rather powerful scene item, and it takes quite a few arguments (args) in the constructor... in order for it to appear and operate in one line of code. Each 'arg' of the one-line constructor is setting a 'necessary initial property' on the scene item. By doing that, we know that it will turn-on/operate with just that one line."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"There are some properties which we set 'behind-the-scenes'. One such property is *intensity*. We 'default' that property to a float 1.0 value. We set that 'necessary initial property' for you. We also call the light's *setEnabled(true)* method."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"I want you to know two important things. First, all properties on a spot light or on any Babylon.js scene item... can be set after the object has been constructed. Second, if you so choose, you can null-out (set to zero/empty) the args in the one-line constructor, and then set all of the necessary initial properties yourself... property by property. You have already seen the fast/simple way to construct the spot light scene item. Below is an example of the slower and less-simple way to construct a spot light."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"var light0 = new BABYLON.SpotLight(\"\", new BABYLON.Vector3.Zero(), new BABYLON.Vector3.Zero(), 0, 0, scene);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.name = \"My Slowly and Discretely Constructed Spot Light\""},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.position = new BABYLON.Vector3(0, 30, -10);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.direction = new BABYLON.Vector3(0, -1, 0);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; frame: 20,"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; value: 0.2"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;});"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;//At the animation key 100, the value of scaling is \"1\""},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;keys.push({"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; frame: 100,"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; value: 1"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;});"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Next, two important steps:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"* Adding the animation array to the animation object:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"animationBox.setKeys(keys);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"* Link this animation to our box:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"box1.animations.push(animationBox);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Finally, you can launch your animation in one line of code, at any time in your application:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"scene.beginAnimation(box1, 0, 100, true);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"####Parameters for scene.beginAnimation"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;| Name | Type | Description"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"---|---|---|---"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;| target | any | The target"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;| from | number | The fps starting frame"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;| to | number | The fps ending frame"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"optional | loop | boolean | If true, the animation will loop (dependent upon BABYLON.Animation.ANIMATIONLOOPMODE)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"optional | speedRatio | number | default : 1. The speed ratio of this animation"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"optional | onAnimationEnd | () => void | The function triggered on the end of the animation (also dependent upon ANIMATIONLOOPMODE)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"optional | animatable | [Animatable](page.php?p=25171) | An optional specific animation"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"---"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"This function returns a ```BABYLON.Animatable``` object that you can use to get access to individual animations (for instance using ```getAnimationByTargetProperty``` function)."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"The ```BABYLON.Animatable``` object also supports the following functions:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```pause()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```restart()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```stop()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```reset()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"These commands will apply to every animation object contained in the Animatable's ._animations array. You can also get access to current running ```BABYLON.Animatable``` objects by using ```scene.getAnimatableByTarget()``` providing the target object."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"And you are done! Don't hesitate to combine many animations for one mesh object... by creating more Animations and pushing them into the mesh's _animation_ property. ;) We have now completed an Animation for box1.scaling.x. Maybe now you want to build an Animation for box1.scaling.y, and really get box1 moving playfully."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"3- **Sprite animation**"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"One of the advantages of sprites is animations. You only have to load one large image file which will contain all animation images, one next to another. Just be careful to respect the square pixel size that you have specified in your manager (e.g. 64 pixel)."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Here is what a complete sprite image looks like:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"![Elements](http://www.babylonjs.com/tutorials/08%20-%20Sprites/08-2.png)"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"This will animate our players in more than 40 positions, depending upon the situation (walking, jumping,…). Babylon's engine is automatically reading sprites on more than one line, so the engine does the work for you :)"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"If you want to begin the animation, simply call this function:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.playAnimation(0, 43, true, 100);"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"By calling « playAnimation » with those parameters, our player will be animated from frame 0 to frame 43. The third parameter is indicating if this animation will loop or not. And the last parameter is the delay between the frames (the smaller it is, the faster the animation)."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Finally, if you want to go to a specific image (e.g. the last one, when the character is not moving), just call:"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```javascript"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"player.cellIndex = 44;"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"```"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"You can play with the scene and code used in this tutorial... by visiting the Babylon.js [**Playground sprites demo**](http://babylonjs-playground.azurewebsites.net/?8)."},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"## Next step"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Don’t hesitate to use sprites in your scene: they are not resource intensive, and they really can help keep high frame rates in your application."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"character.ellipsoid = new BABYLON.Vector3(0.5, 1.0, 0.5);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"character.ellipsoidOffset = new BABYLON.Vector3(0, 1.0, 0);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"var forwards = new BABYLON.Vector3(parseFloat(Math.sin(character.rotation.y)) / speedCharacter, gravity, parseFloat(Math.cos(character.rotation.y)) / speedCharacter);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"forwards.negate();"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"character.moveWithCollisions(forwards);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"// or"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"var backwards = new BABYLON.Vector3(parseFloat(Math.sin(character.rotation.y)) / speedCharacter, -gravity, parseFloat(Math.cos(character.rotation.y)) / speedCharacter);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"character.moveWithCollisions(backwards);"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"Demo by Dad72: [**Move character with gravity and collision**](http://www.castorengine.com/babylon/moveCharacter/)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"## Web worker based collision system (Since 2.1)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"BabylonJS 2.1 allows the user to move the collision calculations to an external web worker thus achieving better rendering time."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"The worker is integrated in the single framework file, and no changes are required by the developer."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"The scene has now a new flag (false per default):"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"scene.workerCollisions = true|false"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"Setting this flag to true will start the worker in the background. The worker will then receive all collision requests from the cameras and meshes. Setting it to false will set the collision to the regular collision calculation as it always was."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"## ArcRotateCamera"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"The ArcRotateCamera can also check collisions but instead of sliding along obstacles, this camera won't move when a collision appends."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"To activate collisions, just call ```camera.checkCollisions = true```. You can define the collision radius with this code:"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```javascript"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"camera.collisionRadius = new BABYLON.Vector3(0.5, 0.5, 0.5)"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"```"},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"## Next step"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- Changing a submesh material,"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"- etc."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"## Next step"},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"This collision method is convenient in a lot of situations. Once you understand mouse pick events, you can begin using that functionality to advance your application’s development."},{"src":"tutorials/10._Intersect_Collisions_-_mesh","name":"10. Intersect Collisions - mesh","text":"In our next tutorial, you will discover how to [check collisions between your scene and the mouse](http://doc.babylonjs.com/page.php?p=22111)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Now you can give some colors to your particles. Color one and two are combined, and “colorDead” is the color that the particle takes-on just before it disappears."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"// Colors of all particles (splited in 2 + specific color before dispose)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Size of particles:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"// Size of each particle (random between...)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.minSize = 0.1;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.maxSize = 0.5;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* LifeTime of particles:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"// Life time of each particle (random between...)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.minLifeTime = 0.3;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.maxLifeTime = 1.5;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Emit rate. This is the density of particles, the rate of particle flow:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.emitRate = 1000;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"![emitRate](http://www.babylonjs.com/tutorials/12%20-%20Particles/12-3.png)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    If you want to launch only a few particles at once, that can be done, as well. For example, if you want to emit only 300 particles:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.manualEmitCount = 300;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    Be aware that the stream is no longer continuous. This is a one-shot particle emission, so this function overrides the previous “emitRate” parameter."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* The selected mode for particles. You can choose between “BLENDMODE_ONEONE” (default choice: source color is added to the destination color without alpha affecting the result), and “BLENDMODE_STANDARD” (to blend current color and particle color using particle’s alpha)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Gravity. You can use gravity if you want to give an orientation to your particles (e.g.: fire particles travel upward on the Y-axis)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"//Set the gravity of all particles (not necessarily down)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Direction. Random direction of each particle after it has been emitted, between direction1 and direction2 vectors."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Now we must remove all light reflections on our box (the sun doesn't reflect on the sky!):"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Next, we apply our special sky texture to it. This texture must have been prepared to be a skybox, in a dedicated directory, named “skybox” in our example:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\"textures/skybox\", scene);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"(More about reflectionTextures can be found in our [Unleash the Standard Material](http://blogs.msdn.com/b/eternalcoding/archive/2013/07/01/babylon-js-unleash-the-standardmaterial-for-your-babylon-js-game.aspx) tutorial.)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"In that `/skybox` directory, we must find 6 sky textures, one for each face of our box. Each image must be named per the corresponding face: “skybox_nx.png”, “skybox_ny.png”, “skybox_nz.png”, “skybox_px.png”, “skybox_py.png”, “skybox_pz.png”."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"![Skybox](http://www.babylonjs.com/tutorials/13%20-%20Environment/13-2.png)"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"If you want some free skybox texture samples, point your browser to: http://3delyvisions.co/skf1.htm (look at licenses before use, please.)&nbsp; As you can see by those examples, skybox textures need not be textures of sky alone.&nbsp; Buildings, hills, mountains, trees, lakes, planets, stars, you name it (all can be used nicely) as part of skybox textures."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Final note, if you want your skybox to render behind everything else, set the skybox's `renderingGroupId` to `0`, and every other renderable object's `renderingGroupId` greater than zero, for example:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"skybox.renderingGroupId = 0;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"// Some other mesh"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"myMesh.renderingGroupId = 1;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"More info about rendering groups and rendering order can be found [here](page.php?p=25100)."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"### Fog"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Fog is quite an advanced effect, but fog in Babylon.js has been simplified to the maximum.&nbsp; It’s now very easy to add fog to your scenes.&nbsp; First, we define the fog mode like this:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.fogMode = BABYLON.Scene.FOGMODE_EXP;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Here are the available modes :"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"- `BABYLON.Scene.FOGMODE_NONE` - default one, fog is deactivated."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"- `BABYLON.Scene.FOGMODE_EXP` - the fog density is following an exponential function."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"- `BABYLON.Scene.FOGMODE_EXP2` - same that above but faster."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"- `BABYLON.Scene.FOGMODE_LINEAR` - the fog density is following a linear function."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"-> If you choose the `EXP`, or `EXP2` mode, then you can define the density option (default is `0.1`):"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.fogDensity = 0.01;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"And now we have a beautiful 3D view of the earth!"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"![HeightMap4](http://www.babylonjs.com/tutorials/14%20-%20Height%20map/14-3.png)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"In my example, I have added a skybox (like we have learned before [here](https://github.com/BabylonJS/Babylon.js/wiki/13-Environment)), and a spotlight to simulate sun activity."},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Here is another example showing what you can achieve with BabylonJS height maps:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"![HeightMap5](http://www.babylonjs.com/tutorials/14%20-%20Height%20map/14-4.png)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"* **Tips**"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"When the user is manipulating the camera, it can be awkward if he can see under the ground, or if he zooms-out outside the skybox. So, to avoid that kind of situation, we can constrain the camera movement:"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```javascript"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"var camerasBorderFunction = function () {"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"        //Angle"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"        if (camera.beta < 0.1)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"            camera.beta = 0.1;"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"        else if (camera.beta > (Math.PI / 2) * 0.9)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"            camera.beta = (Math.PI / 2) * 0.9;"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"  //Zoom"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"        if (camera.radius > 150)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"            camera.radius = 150;"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"        if (camera.radius < 30)"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"            camera.radius = 30;"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"    };"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"    scene.registerBeforeRender(camerasBorderFunction);"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"```"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"You may be interested in visiting [**the playground demo**](http://babylonjs-playground.azurewebsites.net/?14) that goes with this tutorial."},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"## Next step"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"![Hard shadows](http://www.babylonjs.com/forumpics/hard.jpg)"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"*No filter*"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"![Poisson](http://www.babylonjs.com/forumpics/poisson.jpg)"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"*Poisson sampling*"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"![VSM](http://www.babylonjs.com/forumpics/vsm.jpg)"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"*Variance Shadow Map*"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"![BlurVSM](http://www.babylonjs.com/forumpics/blurVSM.jpg)"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"*Blur Variance Shadow Map*"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"## About the light"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Keep in mind that this shadow generator can only be used with one light.  If you want to generate shadows from another light, then you will need to create another shadow generator."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Only directional and spot lights can cast shadows:"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"var light = new BABYLON.DirectionalLight(\"dir01\", new BABYLON.Vector3(-1, -2, -1), scene);"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"You must also define a _position_ for your light (because Babylon.js must have a light's point of view to create the shadow map):"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"light.position = new BABYLON.Vector3(20, 40, 20);"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"```"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Spot lights use perspective projection and directional lights use orthogonal projection. Both projections are evaluated automatically for you to get the best shadow map possible."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"For directional light, you can control the size of the projection window by modifying ```light.shadowOrthoScale``` (0.1 by default which means that the projection window is increase by 10% from the optimal size)."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"The light's position, as well as the positions of the mesh that you have pushed into the renderlist, determine "},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"where the shadows will appear."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Now you might want to visit [**the playground scene**](http://babylonjs-playground.azurewebsites.net/?15) for this tutorial."},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"## Next step"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Vbottom = 1 / 4"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"to each array element, we actually set a different sprite from the first horizontal row to each box face in the _faceUV_ array.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"code :"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var hSpriteNb =  6;  // 6 sprites per raw"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var vSpriteNb =  4;  // 4 sprite raws"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var faceUV = new Array(6);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  for (var i = 0; i < 6; i++) {"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    faceUV[i] = new BABYLON.Vector4(i/hSpriteNb, 0, (i+1)/hSpriteNb, 1 / vSpriteNb);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  }"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Then, to pass this array to the _CreateBox_ method, just add a parameter called _faceUV_, valued with this array, to the options :  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var options = {"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    width: 10,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    height: 3,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    depth: 5,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    faceUV: faceUV"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  };"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var box = BABYLON.Mesh.CreateBox('box', options, scene);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  box.material = mat;"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Here's the result : http://www.babylonjs-playground.com/#1V3CAT#2  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Quite easy, isn't it ?  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"width|_(number)_ size of the width|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"height|_(number)_ size of the height|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"subdivisions|_(number)_ number of square subdivisions|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Disc"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Remembe you can create any kind of regular plane polygon with _CreateDisc()_  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var disc = BABYLON.Mesh.CreateDisc(\"disc\", {tessellation: 3}, scene); // makes a triangle"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"radius|_(number)_ the radius of the disc or polygon|0.5"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tessellation|_(number)_ the number of disc/polygon sides|64"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Torus"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var torus = BABYLON.Mesh.CreateTorus(\"torus\", {thickness: 0.2}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"diameter|_(number)_ diameter of the torus|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"thickness|_(number)_ thickness of its tube|0.5"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tessellation|_(number)_ number of segments along the circle|16"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Torus Knot"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"var torus = BABYLON.Mesh.CreateTorusKnot(\"tk\", {}, scene);"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties, all optional :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"radius|_(number)_ radius of the torus knot|2"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tube|_(number)_ thickness of its tube|0.5"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"radialSegments|_(number)_ number of radial segments|32"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tubularSegments|_(number)_ number of tubular segments|32"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"p|_(number)_ number of windings|2"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"q|_(number)_ number of windings|3"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"###Parametric Shapes"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Lines"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _points_ property.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"lines = BABYLON.Mesh.CreateLines(\"lines\", {points: myArray, instance: lines});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of lines : no need for the parameter scene here"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"points|_(Vector3[])_  array of Vector3, the path of the line **REQUIRED** "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of a line mesh to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Dashed Lines"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _points_ property.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"dashedLines = BABYLON.Mesh.CreateDashedLines(\"dl\", {points: myArray, instance: dashedLines});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of dashedLines : no need for the parameter scene here"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"points|_(Vector3[])_  array of Vector3, the path of the line **REQUIRED** |"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"dashSize|_(number)_  size of the dashes|3"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"gapSize|_(number)_  size of the gaps|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"dashBn|_(number)_  intended number of dashes|200"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var tube =  BABYLON.Mesh.CreateTube(name, path, radius, tessellation, radiusFunction, cap, scene, updatable?, sideOrientation);"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **name** : string."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **path** : an array of successive Vector3. It represents the path the tube will be constructed along. This path is the central axis of the tube. This array must have at least two Vector3. The first point is the start of the tube and the last point is the end of the tube. So having only two points, you get a simple cylinder.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This path can be filled as you like : manually, by importing Vector3 from a data set, with some maths function or even a bit of all of this. It's just an array filled with Vector3 to set where the tube axis goes into space.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **radius** : a radius number value. This is the constant radius value applied along the tube. This value is taken into account only if the _radiusFunction_ parameter is _null_.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  * **tessellation** : the number of radial segments. If you set it to 3 you get a triangular tube section, if you set to 4 you get a squared section, and so on. So set it to what level of precision you need, just keep in mind the more segments, the heavier your mesh.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  *  **cap** : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  *  **radiusFunction** : a custom javascript function.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If you pass this parameter to the _CreateTube()_ method, then the _radius_ parameter value will be ignored.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Your custom function will be called at each point of the path while constructing the tube.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"It will then be passed two arguments : the position of the current point _i_ and the _distance_ of this _i-th_ point from the beginnig of the tube.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Your function must just return a radius value.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Example :"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var myFunction = function(i, distance) {"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  var radius = 3 * Math.cos(distance / 5);"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  return radius;"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"};"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var tube = BABYLON.Mesh.CreateTube(\"lumps\", path, null, 20, myFunction, scene);"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is an example with both an _i_ sinusoidal radius function and _x_ sinusoidal incrementing path :"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"http://www.babylonjs-playground.com/#LG3GS#9    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here's another example with a circular path and varying radius : http://www.babylonjs-playground.com/#LG3GS#10    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"## Extrusion"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"What is extrusion ?  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion is the way to transform a 2D shape into a volumic shape.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's imagine that you define a star shape by filling an array with successive _Vector3_. In order to have a 2D shape, you only set these points in the xOy plane, so every z coordinate is zero.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"ex : http://www.babylonjs-playground.com/#RF9W9  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's show the World axis so it is clearer : http://www.babylonjs-playground.com/#RF9W9#1  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's now imagine you could stretch this 2D shape along the Z-axis to give it some volume... this is extrusion :  http://www.babylonjs-playground.com/#RF9W9#30    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's now imagine you can extrude your star along a 3D path in space, a sinus curve for example, and not only along the z-axis.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"http://www.babylonjs-playground.com/#RF9W9#31    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion can be accomplished with two different methods. A basic one and an advanced or custom one.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"BASIC METHOD  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"BABYLON.Mesh.ExtrudeShape(name, shape, path, scale, rotation, cap, scene, updatable?, sideOrientation)"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **name** : the extruded mesh name."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **shape** : the shape to be extruded, an array of successive Vector3."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **path** : the path to extrude the shape along, an array of successive Vector3."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **scale** : _default 1_, the value to scale the initial shape."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **rotation** : _default 0_, the step value to rotate the shape at each path point."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"*  **cap** : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **scene** : the current scene."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **updatable?** : if the mesh is updatable."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **sideOrientation** : the side orientation - _front, back_ or _double_.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we change the _scale_ value from 1 to 3 for example (line 84), the initial star is scaled to 3 along the curve : http://www.babylonjs-playground.com/#RF9W9#4  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If we now change the _rotation_ step value from 0 to _PI / 24_ for example, the curve is twisted this angle at each curve point : http://www.babylonjs-playground.com/#RF9W9#5  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Of course, even if you define your 2D shape in the xOy plane as described, the extrusion still works along any path direction : http://www.babylonjs-playground.com/#RF9W9#32    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Moreover, the shape doesn't need to be closed. You can have a simple (or complex) open shape : http://www.babylonjs-playground.com/#RF9W9#7  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion : http://www.babylonjs-playground.com/#RF9W9#33      "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion with rotation : http://www.babylonjs-playground.com/#RF9W9#34    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Remember that your shape doesn't need to be centered on the coordinate system either. Here is an offset simple shape : http://www.babylonjs-playground.com/#RF9W9#10  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion (the extrusion path is shown in magenta so the offset is visible) : http://www.babylonjs-playground.com/#RF9W9#35    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"_the cartesian equation y = x * x_ will give the _parametric equation :_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  _x = k_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  _y = k * k_   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You then give _k_ values from -20 to 20 for example and you  get your 40 successive _Vector3_ on the parabola. Easy, isn't it ?  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You now know the way to fill a path with successive _Vector3_ along a math curve.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"### Back to the Ribbon"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Well, we just learnt how to fill a path but a Ribbon needs many paths (okay, we can still construct a ribbon with a single path too, but it's more complex), so how do we add different paths as there is no real interest to add many times the same path ?   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"It's quite easy once you've got your parametric equation.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's get into javascript now.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Your former parametric equation could be this way :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var k = -20; k <= 20; k++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var x = k;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var y = k * k;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var z = 0;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  path.push(new BABYLON.Vector3(x, y, z));"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Right ?   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"http://www.babylonjs-playground.com/#1HSC2O   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's now imagine, you create the same path array 10 times on the z-axis with _z = t_ :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var paths = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var t = 0; t < 10; t++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  for (var k = -20; k <= 20; k++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var x = k;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var y = k * k;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var z = t;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push(new BABYLON.Vector3(x, y, z));"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  paths.push(path);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"What do we get now ?   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"http://www.babylonjs-playground.com/#1HSC2O#1   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"An array _paths_ filled with 10 similar _paths_.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Just what is needed to create a ribbon : http://www.babylonjs-playground.com/#1HSC2O#2   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"If you now change slightly each path equation so they aren't all similar, say, by dividing _y_ by _t_ :  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var paths = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var t = 1; t < 10; t++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  for (var k = -20; k <= 20; k++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var x = k;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var y = k * k / t;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var z = t;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push(new BABYLON.Vector3(x, y, z));"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  paths.push(path);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You immediatly get a set of different paths along the z-axis : http://www.babylonjs-playground.com/#1HSC2O#8   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"So a more complex ribbon : http://www.babylonjs-playground.com/#1HSC2O#9     "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"At last, if we change a bit _x_ and _z_ variation to scale the curve, we can get a nice parabolic shape :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var paths = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var t = 1; t < 10; t++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  for (var k = -20; k <= 20; k++) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var x = k * 8;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var y = k * k / t;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var z = t * 50;"},{"src":"tutorials/Supporting_fog_with_ShaderMaterial","name":"Supporting fog with ShaderMaterial","text":"And, you are done :)"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"There are three more things to add to your web page.  First, a 'call' to the createScene function that we just completed.  Add this:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```javascript"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // Now, call the createScene function that you just finished creating"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  var scene = createScene();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```  "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Then, the all-important rendering loop.  Add this:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```javascript"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // Register a render loop to repeatedly render the scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  engine.runRenderLoop(function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    scene.render();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  });"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```  "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"And last, an optional but handy canvas/window resize event handler.  Add this:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```javascript"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  // Watch for browser/canvas resize events"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  window.addEventListener(\"resize\", function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"    engine.resize();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"  });"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"There.  All the Javascript inserting is done.  Make sure you close the script, body, and html elements. The last three lines of your HTML5 web page... should be:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```html"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</body>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</html>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"You are done! Save your file (in the same folder as babylon.js, hand.js, and cannon.js) and browse it with your WebGL-ready browser.  You should see your new scene displayed in 3D on its canvas."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"A near-exact duplicate of the createScene function used in this tutorial... can be seen [**RIGHT HERE**](http://www.babylonjs.com/playground/#1GM4YQ) at the Babylon.js Playground.  You will also see the scene render LIVE, ONLINE!  Use the playground's 'Get .zip' choice if you want to download the entire index.html file used in this tutorial."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"## Got Troubles? ##"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Here is what the entire web page should look like:"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```html"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<!doctype html>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<html>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<head>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <meta charset=\"utf-8\">"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <title>Babylon - Basic scene</title>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <style>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      html, body {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         overflow: hidden;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         width: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         height: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         margin: 0;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         padding: 0;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      }"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      #renderCanvas {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         width: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         height: 100%;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         touch-action: none;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      }"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   </style>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <script src=\"babylon.js\"></script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <script src=\"hand.js\"></script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <script src=\"cannon.js\"></script> <!-- optional physics engine -->"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</head>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"<body>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <canvas id=\"renderCanvas\"></canvas>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   <script type=\"text/javascript\">"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Get the canvas element from our HTML below"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      var canvas = document.querySelector(\"#renderCanvas\");"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Load the BABYLON 3D engine"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      var engine = new BABYLON.Engine(canvas, true);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // -------------------------------------------------------------"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Here begins a function that we will 'call' just after it's built"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      var createScene = function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Now create a basic Babylon Scene object"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         var scene = new BABYLON.Scene(engine);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Change the scene background color to green."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         scene.clearColor = new BABYLON.Color3(0, 1, 0);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // This creates and positions a free camera"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // This targets the camera to scene origin"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         camera.setTarget(BABYLON.Vector3.Zero());"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // This attaches the camera to the canvas"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         camera.attachControl(canvas, false);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // This creates a light, aiming 0,1,0 - to the sky."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         var light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Dim the light a small amount"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         light.intensity = .5;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Let's try our built-in 'sphere' shape. Params: name, subdivisions, size, scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         var sphere = BABYLON.Mesh.CreateSphere(\"sphere1\", 16, 2, scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Move the sphere upward 1/2 its height"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         sphere.position.y = 1;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Let's try our built-in 'ground' shape. Params: name, width, depth, subdivisions, scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         var ground = BABYLON.Mesh.CreateGround(\"ground1\", 6, 6, 2, scene);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         // Leave this function"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         return scene;"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      }; // End of createScene function"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Lines Mesh**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var lines = BABYLON.Mesh.CreateLines(\"lines\", ["},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    new BABYLON.Vector3(-10, 0, 0),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    new BABYLON.Vector3(10, 0, 0),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    new BABYLON.Vector3(0, 0, -10),"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    new BABYLON.Vector3(0, 0, 10)"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"], scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, [array of comma-separated vectors], scene. "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"I could explain how the Lines Mesh constructor works, but I think you can see how it works just by looking at the demo code above.  Notice the [ and ].  Those are the enclosing tokens for an array, yet another kind of Javascript value.  The first vector3 of the array is the starting location for drawing lines.  After that, a comma, and then the next vector3 location... indicating where the line is drawing-to next.  Then, another comma, and another vector3 to a new location.  You can add as many vectors as you wish, but notice that the LAST vector3 does not have a comma following it.  Please make your array of vectors be formatted similarly.    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of DashedLines Mesh**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var dashedlines = BABYLON.Mesh.CreateDashedLines(\"dashedLines\", [v1, v2, ... vn], dashSize, gapSize, dashNb, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are : name, [array of Vectors3], dashSize, gapSize, dashNumber, scene.    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"As for Lines, a line along the vectors3 will be displayed in space. It will try to set _dashNumber_ strokes on this line depending on the length of each segment between two successive vectors3.    "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"_dashSize_ and _gapSize_ are relative to each other dash and gap sizes within these strokes.   "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Ribbon**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"What is a ribbon ?  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Imagine a first series of successive points defining a path.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Now get another series of successive points, so another path.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If you construct then triangular faces by joining alternately each point of the first and the second path like when you lace shoes, you get a ribbon.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Your paths don't need to be parallel. They don't even need to be straight lines or in the same plane.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"They are, well, what you want. The ribbon will just follow your paths.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Now, imagine, instead of having only two paths, you've got many successive different paths.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"The full ribbon will then be the continuous surface joining all these inbetween pair of paths surface."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", [path1, path2, ..., pathn], false, false, 0, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, pathArray, closeArray, closePath, offset, scene, updatable? (if the mesh must be modified later)  and the optional side orientation (see below)."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * name : a string, the name you want to give to your shape,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * pathArray : an array populated with paths. Paths are also arrays, populated with series of successive _Vector3_. You need at least one path to construct a ribbon and each path must contain at least four _Vector3_,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * closeArray : boolean, if true an extra set of triangles is constructed between the last path and the first path of _pathArray_,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * closePath : boolean, if true the last point of each path of _pathArray_ is joined to the first point of this path,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * offset : integer (default half the _path_ size) mandatory only if the _pathArray_ contents only one path. The ribbon will be constructed joining each i-th point of the single path to the i+offset-th point. It is ignored if _pathArray_ has got more than one path,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * scene : the current scene,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * updatable : if the ribbon should updated later"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * sideOrientation : the wanted side orientation (front, back or double side)."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", [path1, path2, ..., pathn], false, false, 0, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"I you need more details about how to deal with this method, you would probably read the [**Parametric Shapes**]() part."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* ** Creation of a Tube**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var tube = BABYLON.Mesh.CreateTube(\"tube\", [V1, V2, ..., Vn], radius, tesselation, radiusFunction, cap, scene, false, BABYLON.Mesh.DEFAULTSIDE);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are : name, path, radius, tesselation, optional radiusFunction, cap, scene, updatable, sideOrientation."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * name : string, the name of the tube mesh,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * path : an array of successive Vector3, at least two Vector3,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * radius : the tube radius, taken into account when _radiusFunction_ parameter set to _null_,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * tesselation : the number of radial segments,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * radiusFunction : _optional_, a javascript function returning a radius value, can be let to _null_,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * cap : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL,  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * updatable : if the tube could be updated later,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * sideOrientation : the wanted side orientation (front, back or double side)."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"These two last parameters can be omitted if you just need the default behavior :"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var tube = BABYLON.Mesh.CreateTube(\"tube\", [V1, V2, ..., Vn], radius, tesselation, radiusFunction, cap, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"The tube can be used also as a [**Parametric Shapes**]() by setting a radius function."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"#### Updatable"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"This parameter present in each mesh creation method tells if the mesh could be updated once it is created.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If false (default value), the mesh data are passed only once to the GPU.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If true, the mesh data may be recomputed and passed to the GPU at each frame refresh.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"#### Side Orientation"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"When a mesh is created, a side orientation is given to it.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"The side orientation is used to give visibility and/or light reflection to each side of the mesh.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"There are four possible values for this parameter :  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * BABYLON.Mesh.FRONTSIDE,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * BABYLON.Mesh.BACKSIDE,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * BABYLON.Mesh.DOUBLESIDE,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"  * BABYLON.Mesh.DEFAULT which is the default value and equals FRONTSIDE currently."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"This parameter is optional. If not given, the DEFAULT value is set.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"*(We assume the backFaceCulling is enabled by default)*  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"For instance, imagine you create a basic shape like a box, a sphere or a plane and you don't give it a material.   "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If you go behind the plane or inside the box or the sphere, you can check that the faces aren't visible any longer : this meshes are constructed with the default side orientation _FRONTSIDE_. This means each side is only a front view.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"test it : http://www.babylonjs-playground.com/#14RNAU#4  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If you give your former mesh a material and light it up, you can then check the back (or internal) face is now visible, but it doesn't reflect the light. Same reason : the default side orientation is still _FRONTSIDE_.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"*(you can disable _backFaceCulling_ with this _sideOrientation_ value)*"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Now just change the _sideOrientation_ parameter to _BABYLON.Mesh.BACKSIDE_.   "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"As you can then check, you can now only see either the back of the plane or the inside of the box or the sphere.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"test it : http://www.babylonjs-playground.com/#14RNAU#5  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"If you give your mesh some material, you can then check the light now only reflects on the back face (plane) or only inside (box, sphere, etc).  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"*(you can disable _backFaceCulling_ with this _sideOrientation_ value)*"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"At last, change the _sideOrientation_ parameter to _BABYLON.Mesh.DOUBLESIDE_.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"As you guess, now the mesh faces are visible both sides. And if you give it a material, the light then reflects both sides too.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"test it : http://www.babylonjs-playground.com/#14RNAU#6   "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"So why not always use _BABYLON.Mesh.DOUBLESIDE_ by default ?  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Because this value creates twice more vertices than the mesh needs to be rendered with only one side. In other terms, your mesh will be twice heavier.  "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"*(you shouldn't disable _backFaceCulling_ with _BABYLON.Mesh.DOUBLESIDE_ value)*"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"### More Basic Elements - Grounds"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Up to this point, we have been talking about basic elements from our [**Playground Demo Scene 02**](http://babylonjs-playground.azurewebsites.net/?2), but three important mesh shapes (basic elements) are not included in that demo scene.  They are each ways of making 'ground' in Babylon.js.  Let's take a look: "},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Ground**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"The specular property has one more setting.  The size/intensity of the specular reflection can be set using the ```specularPower``` property:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.specularPower = 32;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"*** Section on OpacityTexture needed here, coming soon. ***"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"There, we have visited the primary color and texture properties of StandardMaterial.  But we are not done yet.  Here are a few more handy properties."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **Back-Face Culling**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Simply put, “back-face culling” determines whether or not a StandardMaterial is visible from its back side (from behind).  TRUE = NOT visible.  More precisely, this rendering-speed-optimization technique determines if a polygon of a graphical object is visible or not. If set to TRUE or boolean 1, the  Babylon engine won’t render hidden face(s) of the meshes that use this material. It is set TRUE by default, but can be changed to false as wanted. You may want to read more about back-face culling at [the wikipedia page about it](http://en.wikipedia.org/wiki/Back_face_culling).  "},{"src":"tutorials/04._Materials","name":"04. Materials","text":"In this example, the texture has some alpha, and back-face culling is set to false for the front sphere... in order to see its black inside face:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"![tof](http://www.babylonjs.com/tutorials/04%20-%20Materials/04-2.png)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.backFaceCulling = false;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"* **WireFrame**"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"You can see your object in wireframe mode... by using:"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"```javascript"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"materialSphere1.wireframe = true;"},{"src":"tutorials/04._Materials","name":"04. Materials","text":" ```"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"![tof](http://www.babylonjs.com/tutorials/04%20-%20Materials/04-3.png)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Again, you can see things from this tutorial... come to life... by browsing to [the Babylon.js Playground scene 4](http://www.babylonjs.com/playground/?4)."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"More information about materials can be found by reading [**Unleash the StandardMaterial**](http://blogs.msdn.com/b/eternalcoding/archive/2013/07/01/babylon-js-unleash-the-standardmaterial-for-your-babylon-js-game.aspx) and also [**Advanced Texturing**](http://doc.babylonjs.com/page.php?p=22161)."},{"src":"tutorials/04._Materials","name":"04. Materials","text":"##Next step##"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"----"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"With the touch of a touchscreen, or the click of a mouse button, the virtual joysticks activate. Not a bit of extra work for you. Like everything in Babylon.js, we try to make it easy and enjoyable. Here is how to construct a Babylon.js VirtualJoysticksCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// VirtualJoysticksCamera >> Move in your world with on-screen Virtual Joysticks"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.VirtualJoysticksCamera(\"VJ_camera\", new BABYLON.Vector3(0, 1, -15), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The VirtualJoysticksCamera also uses a FreeCamera as its basis, so all the properties and methods of our familiar FreeCamera... are found on our VirtualJoysticksCamera as well. "},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"We have a [special tutorial dedicated to the VirtualJoysticksCamera](http://doc.babylonjs.com/page.php?p=22502)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"You can explore all the properties and methods available on the VirtualJoysticksCamera... at [**our API documentation site**](http://doc.babylonjs.com/page.php?p=23887)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **AnaglyphCamera** - The AnaglyphCamera is for use with red and cyan 3D glasses. It is very new to Babylon.js, and to be honest quite sexy. It uses post-processing filtering techniques. There are actually two types of AnaglyphCamera."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The first is the **AnaglyphArcRotateCamera**. Its constructor looks like this:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// AnaglyphArcRotateCamera >> Analglyph 3D using filter-shifted ArcRotateCamera"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, alpha, beta, radius, target (in Vector3), eyeSpace (in degrees), scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"var camera = new BABYLON.AnaglyphArcRotateCamera(\"aar_cam\", -Math.PI/2, Math.PI/4, 20, new BABYLON.Vector3.Zero(), 0.033, scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The second is the **AnaglyphFreeCamera**. Its constructor looks like this:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// AnaglyphFreeCamera >> Analglyph 3D using filter-shifted FreeCamera"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position (in Vector3), eyeSpace (in degrees), scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"var camera = new BABYLON.AnaglyphFreeCamera(\"af_cam\", new BABYLON.Vector3(0, 1, -15), 0.033, scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The _eyeSpace_ parameter (and property) sets the amount of shift between the left eye view and the right eye view. Once you are wearing your 3D glasses, you might want to experiment with this float value."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"You can learn all about anaglyphs by visiting a [Wikipedia page that explains it thoroughly](http://en.wikipedia.org/wiki/Anaglyph_3D). "},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **GamepadCamera** - Local superhero David \"davrous\" Rousset, who invented our cool VirtualJoysticksCamera, is also the inventor of our cool GamepadCamera. Thanks David!  The Babylon.js GamepadCamera is specially designed to work with... you guessed it... gamepads. This camera works closely with Babylon.js Gamepad, Gamepads, and Xbox360Pad classes. More will be written about that, soon, and nearby."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"Ok, let's create a GamepadCamera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// GamepadCamera >> Move in your scene with gamepad controls"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"var camera = new BABYLON.GamepadCamera(\"Camera\", new BABYLON.Vector3(0, 15, -45), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"Easy. Many of the powerful properties and methods found on our familiar FreeCamera... are also found on our GamepadCamera. Take notice of the ._angularSensibility_ and ._moveSensibility_ properties, similar to our DeviceOrientationCamera. You can explore all the properties and methods available on the GamepadCamera... at [our API documentation site](http://doc.babylonjs.com/page.php?p=23881)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **VRDeviceOrientationFreeCamera** - The [VRDeviceOrientationFreeCamera](https://github.com/BabylonJS/Babylon.js/blob/master/Babylon/Cameras/VR/babylon.vrDeviceOrientationCamera.js) is yet to be documented."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// VRDeviceOrientationFreeCamera >> Move in your VR scene with device orientation"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.VRDeviceOrientationFreeCamera(\"VRDO\", new BABYLON.Vector3(0, 1, -15), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The VRDeviceOrientationFreeCamera uses FreeCamera as its basis, so all of the properties and methods of FreeCamera... are also found on our VRDeviceOrientationFreeCamera. "},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"* **WebVRFreeCamera** - The [WebVRFreeCamera](https://github.com/BabylonJS/Babylon.js/blob/master/Babylon/Cameras/VR/babylon.webVRCamera.js) is yet to be documented."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// WebVRFreeCamera >> Move in your VR scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Parameters : name, position, scene"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"    var camera = new BABYLON.WebVRFreeCamera(\"WVR\", new BABYLON.Vector3(0, 1, -15), scene);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"The WebVRFreeCamera uses FreeCamera as its basis, so all of the properties and methods of FreeCamera... are also found on our WebVRFreeCamera."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"## Wrapping Up ##"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"As a last reminder, Babylon.js cameras require you to use “attachControl” and “detachControl” functions, as needed. Most Babylon.js experts... use a two-step process to activate and attach a camera:"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```javascript"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// First, set the scene's activeCamera... to be YOUR camera."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   scene.activeCamera = myCamera;"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"// Then attach the activeCamera to the canvas."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"   scene.activeCamera.attachControl(canvas);"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"```"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"You already knew about activating and attaching cameras, didn't you? You remembered from the last time I told you, right? :)"},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"## Next step"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.angle = 0.8;"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.exponent = 2;"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.intensity = 0.5;"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.diffuse = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.specular = new BABYLON.Color3(1, 1, 1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light0.setEnabled(1);"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Using this 'long method' of scene item constructing... is rarely necessary or wanted. But we thought you should know that you can do constructing in this way, if you so choose."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"## Normals and Backfaces - Seeing the Light: ##"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"You may have heard words like '_normals_' and '_backfaces_' spoken or written, during your 3D travels. We will not be deeply examining those two terms in this tutorial, but I am going to try to explain how normals and backfaces... affect lights. "},{"src":"tutorials/06._Lights","name":"06. Lights","text":"The picture below will help you understand how lights interact with normals and backfaces. The picture shows two planes and two lights. One light is a spot light, the other is a point light. The arrows show the direction of the lighting normals, and these arrows are not visible in a standard scene. They are used in the picture to help illustrate the concept of normals, as are the diamond and cone shapes for the two lights. Let's look at the picture carefully."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"![](http://urbanproductions.com/wingy/babylon/misc/normals03.jpg)"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"&nbsp;_A blue back-faced plane and a blue front-faced plane, with a spot light and point light_"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"As you can see, when a standard Babylon.js plane has its backface lit (the left plane), the lights have no affect, because its normals are not facing toward the lights. Conversely, when a standard plane has its frontface lit (the right plane), both lights work perfectly to light the plane, because its normals are facing toward the lights. "},{"src":"tutorials/06._Lights","name":"06. Lights","text":"It is also interesting to note that neither plane blocks the lights. You can see that the arrows on the left plane, are lit by the lights. The plane is not blocking the light rays. The only way that any mesh can block light rays in Babylon.js, is with the use of a ShadowGenerator or two. "},{"src":"tutorials/06._Lights","name":"06. Lights","text":"As a last note, I want you to know that the left plane's material.backFaceCulling = false. Whether it is set to true or false, there will be no change in how lights affect backfaces. The lights are primarily concerned about the direction of the lighting normals (the arrows). The standard Babylon.js plane (and ground) has its lighting normals aimed toward the frontface."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"**NEW**: In recent versions of Babylon.js, a new property was introduced... called _.range_:"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```javascript"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"light.range = 300;"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"```"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"More information about the _.range_ property... coming soon. Stay tuned."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"## Next Step ##"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"With the use of these powerful lights, your scene is likely really starting to 'shine'. And don't forget that you can animate light positions, directions, colors, and therefore create wonderful 'light shows'. We'll talk about that soon, or have fun discovering how to do it on your own. Maybe you could do light property settings inside the scene's render loop function. Its fun and beautiful!"},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Although not truly a light, you might be interested in our [Volumetric Light Scattering](http://doc.babylonjs.com/page.php?p=24840) (GodRays) system."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"**2 - Controlling animations**"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Each Animation has a property called ```currentFrame``` that indicates the current animation key."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"For advanced keyframe animation, you can also define the functions used to interpolate (transition) between keys. By default these functions are the following:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"BABYLON.Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;return startValue + (endValue - startValue) * gradient;"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"};"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"BABYLON.Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;return BABYLON.Quaternion.Slerp(startValue, endValue, gradient);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"};"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"BABYLON.Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;return BABYLON.Vector3.Lerp(startValue, endValue, gradient);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"};"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"**3 - Helper function**"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You can use an extended function to create a quick animation:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```Javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Animation.CreateAndStartAnimation = function(name, mesh, tartgetProperty, framePerSecond, totalFrame, from, to, loopMode);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"To be able to use this function, you need to know that :"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- Your animation will have predefined key frames (Only 2 keyframes are generated : **Start** and **End**)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- The animation works only on **AbstractMesh** objects."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- The animation is starting right after the method call."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Here is a straightforward sample using the **CreateAndStartAnimation()** function :"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```Javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"BABYLON.Animation.CreateAndStartAnimation('boxscale', box1, 'scaling.x', 30, 120, 1.0, 1.5);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Pretty straightforward ? :)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"**4 - Easing functions**"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You can add some behaviors to your animations, using easing functions. "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"If you want more informations about easing functions, here are some useful links : "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- [MSDN Easing functions documentation](http://msdn.microsoft.com/en-us/library/ee308751.aspx)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- [Easing functions cheat sheet](http://easings.net/fr)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"All those easing functions are implemented in BABYLON allowing you to apply custom mathematical formulas to your animations."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Here are the predefined easing functions you can use : "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.CircleEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.BackEase(amplitude)```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.BounceEase(bounces, bounciness)```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.CubicEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.ElasticEase(oscillations, springiness)```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.ExponentialEase(exponent)```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.PowerEase(power)```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.QuadraticEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.QuarticEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.QuinticEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.SineEase()```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You can use the **EasingMode** property to alter how the easing function behaves, that is, change how the animation interpolates. "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"There are three possible values you can give for EasingMode: "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.EasingFunction.EASINGMODE_EASEIN``` : Interpolation follows the mathematical formula associated with the easing function."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.EasingFunction.EASINGMODE_EASEOUT``` : Interpolation follows 100% interpolation minus the output of the formula associated with the easing function."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"- ```BABYLON.EasingFunction.EASINGMODE_EASEINOUT``` : Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Here is a straightforward sample to animate a torus within a ```CirleEase``` easing function :"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```Javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"//Create a Vector3 animation at 30 FPS"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var animationTorus = new BABYLON.Animation(\"torusEasingAnimation\", \"position\", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// the torus destination position"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var nextPos = torus.position.add(new BABYLON.Vector3(-80, 0, 0));"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// Animation keys"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var keysTorus = [];"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"keysTorus.push({ frame: 0, value: torus.position });"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"keysTorus.push({ frame: 120, value: nextPos });"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"animationTorus.setKeys(keysTorus);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// Creating an easing function"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var easingFunction = new BABYLON.CircleEase();"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// For each easing function, you can choose beetween EASEIN (default), EASEOUT, EASEINOUT"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// Adding the easing function to the animation"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"animationTorus.setEasingFunction(easingFunction);"},{"src":"tutorials/08._Sprites","name":"08. Sprites","text":"Now you know how to create a complete simple dynamic scene and it is going to be important to talk about [collisions](http://doc.babylonjs.com/page.php?p=22101)."},{"src":"tutorials/09._Cameras,_Mesh_Collisions_and_Gravity","name":"09. Cameras, Mesh Collisions and Gravity","text":"Great, now you can develop a real FPS game! But maybe you would like to know when a mesh is in collision with another mesh? Good, because that is exactly the purpose of our [next tutorial](http://doc.babylonjs.com/page.php?p=22101)."},{"src":"tutorials/11._Picking_Collisions","name":"11. Picking Collisions","text":"Now you should know everything about collisions, so it’s time to move on to a classic effect in 3D : [particles](http://doc.babylonjs.com/page.php?p=22121)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"![emitRate](http://www.babylonjs.com/tutorials/12%20-%20Particles/12-4.png)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* AngularSpeed. You can define a Z-axis rotation for each particle (in radian):"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.minAngularSpeed = 0;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.maxAngularSpeed = Math.PI;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Speed/Strength. You can define the power of emitting particles, and the overall motion speed (0.01 is default update speed, faster updates = faster animation)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.minEmitPower = 1;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.maxEmitPower = 3;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.updateSpeed = 0.005;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Duration. You can set the amount of time the particle system is running (depends of the overall speed above)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.targetStopDuration = 5;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"* Dispose. Disposes (or not) the particle system on stop (very useful if you want to create a one shot particle system with a specific targetStopDuration):"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.disposeOnStop = true;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Finally, you can start this particle system whenever you want in your code with:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.start();"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"And naturally stop it:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"particleSystem.stop();"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Feel free to play with this scene... [**at our online playground**](http://babylonjs-playground.azurewebsites.net/?12)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"### customEffect (the fourth parameter in the constructor)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"var ps = new BABYLON.ParticleSystem(\"particles\", 2000, scene, **customEffect**);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The customEffect is a type of BABYLON.Effect used to target a valid shader program."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The primary author of Babylon.js was kind enough to make us [a fantastic playground demo of a particle system using a fragment shader effect](http://babylonjs-playground.azurewebsites.net/#1ASENS). Visit that link, and you can see a fragment shader program that has been stored in a shader store. Notice the line:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"BABYLON.Effect.ShadersStore[\"myParticleFragmentShader\"] = [...]"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"A bit below that, you will see:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```javascript"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"var effect = engine.createEffectForParticles(\"myParticle\", [\"time\"]);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"_.createEffectForParticles_ accepts the following parameters:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"- fragment name (can be in the shaders store or the id of a DOM element)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"- array of additional parameters (uniforms)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"- array of additional samplers (for additional textures!)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The particle Effect Object is a slightly-modified [Babylon Effect Object](http://doc.babylonjs.com/page.php?p=24951). Also notice that the ShadersStore is a namespace upon this special [Effect Object](http://doc.babylonjs.com/page.php?p=24951). "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"The Effect Object has many 'setter' methods on it, one of which is _.setFloat_. Notice how it is used in the registerBeforeRender function. This causes the speed of the effect to cycle across about a 20 second time span. We are (the demo author is) varying the time parameter of the fragment shader program... from within the scene's render loop! WE LOVE IT!"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Here is a short comment from Deltakosh... regarding that playground demo linked above:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"> By default Babylon.js will give you a vUV and a vColor varying parameter. It will also transmit you the particle texture. But you can feel free to add any new parameter, like I did, with 'time'."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"This section of the tutorial is under construction. We will have much more to say, soon."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"## Custom functions"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"You can get even more control over particles by using custom functions:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```startDirectionFunction: (emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3)```: This function can be defined to specify initial direction for every new particle. By default, this function is defined with the following code:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    startDirectionFunction = (emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3): void => {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randX = randomNumber(this.direction1.x, this.direction2.x);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randY = randomNumber(this.direction1.y, this.direction2.y);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randZ = randomNumber(this.direction1.z, this.direction2.z);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        Vector3.TransformNormalFromFloatsToRef(randX * emitPower, randY * emitPower, randZ * emitPower, worldMatrix, directionToUpdate);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    }"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"-> Otherwise, if you choose `LINEAR` mode, then you can define where fog starts and where fog ends:"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.fogStart = 20.0;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.fogEnd = 60.0;"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"Finally, whatever the mode, you can specify the color of the fog (default is `BABYLON.Color3(0.2, 0.2, 0.3)`):"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```javascript"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"```"},{"src":"tutorials/13._Environment","name":"13. Environment","text":"See, we told you it was easy."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"If you want to see and play with the playground scene for this tutorial, you can [**click right here**](http://babylonjs-playground.azurewebsites.net/?13)."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"## Next step"},{"src":"tutorials/14._Height_Map","name":"14. Height Map","text":"Well done! Your scene looks good now, and you can imagine a lot of new landscapes! One more important thing you need to know is [how to create shadows](http://doc.babylonjs.com/page.php?p=22151). Shadows will give your scene a beautiful rendering effect, don't forget it!"},{"src":"tutorials/15._Shadows","name":"15. Shadows","text":"Now that you are becoming a real professional about Babylon.js, maybe it’s time to go deeper into the code to manipulate complex shaders, mesh, or textures. Our [home menu for our wiki](http://doc.babylonjs.com/) is your portal to many advanced topics. You can also participate in this project by going to our Github page: [https://github.com/BabylonJS/Babylon.js](https://github.com/BabylonJS/Babylon.js) and also by participating in our very active forum: [http://www.html5gamedevs.com/forum/16-babylonjs](http://www.html5gamedevs.com/forum/16-babylonjs). See you there."},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Now let's look at the red haired character on the top face of the box. He has his head on the left, correct ?  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"What if we want to flip only this face ?  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"This face is the box face 4 (just make attempts to discover the box geometry). We just then need to swap _y_ and _w_ coordinate values :  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var f = 4;"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var temp = faceUV[f].y;"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  faceUV[f].y = faceUV[f].w;"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  faceUV[f].w = temp;"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"And now, his head is in on the right : http://www.babylonjs-playground.com/#1V3CAT#3  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Obviously, we aren't not required to set every box face.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Imagine we want to set only the face 4.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Forget about the _for{}_ loop, just initialize our _faceUV_ array and set only _faceUV[4]_ :  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var faceUV = new Array(6);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  faceUV[4] = new BABYLON.Vector4(0, 0, 1 / hSpriteNb, 1 / vSpriteNb);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Only two lines of code only and that's all : http://www.babylonjs-playground.com/#1V3CAT#4  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"We could also want to apply two different images from the same texture file onto two different meshes.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Nothing easier : http://www.babylonjs-playground.com/#1V3CAT#9   "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Two boxes, two images, but only one texture !"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"<br/>"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"###Colors"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Let's go back to our initial rectangular box : http://www.babylonjs-playground.com/#1V3CAT  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"We are about to apply the same principle here not with textures, but with colors.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Let's define a 6 element array _faceColors_ (6 box faces) and just set the color of the faces we want with _Colors4_.  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var faceColors = new Array(6);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  faceColors[4] = new BABYLON.Color4(1,0,0,1);   // red top"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  faceColors[1] = new BABYLON.Color4(0,1,0,1);   // green front"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Then pass this array to the _CreateBox_ method with the new faceColors parameter of _options_  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var options = {"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    width: 10,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    height: 3,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    depth: 5,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    faceColors : faceColors"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  };"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var box = BABYLON.Mesh.CreateBox('box', options, scene);"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Simple, isn't it ?  http://www.babylonjs-playground.com/#1V3CAT#5  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of a line mesh to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Ribbon"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _pathArray_ property.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"ribbon = BABYLON.Mesh.CreateRibbon(\"ribbon\", {pathArray: myPaths, instance: ribbon});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of ribbon : no need for the parameter scene"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"pathArray|_(Vector3[][])_  array of array of Vector3, the array of paths **REQUIRED** "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"closeArray|_(boolean)_  to force the ribbon to join its last and first paths|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"closePath|_(boolean)_  to force each ribbon path to join its last and first points|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"offset|_(number)_  used if the pathArray has one path only|half the path length"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of a ribbon to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Tube"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _path_ property.  "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tube = BABYLON.Mesh.CreateTube(\"tube\", {path: myPath, instance: tube});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of tube : no need for the parameter scene"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"path|_(Vector3[])_  array of Vector3, the path of the tube **REQUIRED** |"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"radius|_(number)_  the radius of the tube|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"tessellation|_(number)_  the number of radial segments|64"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"radiusFunction|_( function(i, distance) )_  a function returning a radius value from _(i, distance)_ parameters|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"cap|_(number)_ tube cap : NO_CAP, CAP_START, CAP_END, CAP_ALL|NO_CAP"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of a tube to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Extruded Shapes"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _shape_ and _path_ properties"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"extruded = BABYLON.Mesh.ExtrudeShape(\"ext\", {shape: myShape, path: myPath, scale: newScale, rotation: newRotation instance: extruded});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of extruded : no need for the parameter scene"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"shape|_(Vector3[])_  array of Vector3, the shape you want to extrude **REQUIRED** |"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"path|_(Vector3[])_  array of Vector3, the extrusion axis **REQUIRED** |"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"scale|_(number)_  the value to scale the shape|1"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"rotation|_(number)_  the value to rotate the shape each step along the path|0"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"cap|_(number)_ extrusion cap : NO_CAP, CAP_START, CAP_END, CAP_ALL|NO_CAP"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of an extruded shape to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"####Custom Extruded Shapes"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"You must set at least the _shape_ and _path_ properties"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Example :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```javascript"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"extruded = BABYLON.Mesh.ExtrudeShapeCustom(\"ext\", {shape: myShape, path: myPath, scaleFunction: myScaleF, rotation: myRotF instance: extruded});"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"// updates the existing instance of extruded : no need for the parameter scene"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"```"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"Properties :"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"property|value|default value"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"--------|-----|-------------"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"shape|_(Vector3[])_  array of Vector3, the shape you want to extrude **REQUIRED**| "},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"path|_(Vector3[])_  array of Vector3, the extrusion axis **REQUIRED** |"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"scaleFunction|_( function(i, distance) )_  a function returning a scale value from _(i, distance)_ parameters|{return 1;}"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"rotationFunction|_( function(i, distance) )_  a function returning a rotation value from _(i, distance)_ parameters|{return 0;}"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"ribbonClosePath|_(boolean)_ the underlying ribbon _closePath_ parameter value|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"ribbonCloseArray|_(boolean)_ the underlying ribbon _closeArray_ parameter value|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"cap|_(number)_ extrusion cap : NO_CAP, CAP_START, CAP_END, CAP_ALL|NO_CAP"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"updatable|_(boolean)_ true if the mesh is updatable|false"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"sideOrientation|_(number)_ side orientation|DEFAULTSIDE"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"instance|_(LineMesh)_ an instance of an extruded shape to be updated|null"},{"src":"tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter","name":"Mesh CreateXXX Methods With Options Parameter","text":"_edition in progress_"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Now rotation... around the path axis : http://www.babylonjs-playground.com/#RF9W9#36    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"As you can see, this is a way to build complex curved helix meshes without handling maths or simpler ones : http://www.babylonjs-playground.com/#RF9W9#37    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"As the shape to be extruded is unpredictable, it is assumed that the cap, if want to add it one or two to your extruded mesh, is computed with its center set to the shape barycenter.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"ADVANCED METHOD  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"BABYLON.Mesh.ExtrudeShapeCustom(name, shape, path, scaleFunction, rotateFunction, ribbonCloseArray, ribbonClosePath, cap, scene)"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **name** : the extruded mesh name,"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **shape** : the shape to be extruded, an array of successive Vector3."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **path** : the path to extrude the shape along, an array of successive Vector3."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **scaleFunction** : a custom javascript function. This function is called on each path point and is given the _i_ position of the point in the path and its _distance_ from the begining of the path. It must return a _scale_ numeric value. This value will be the scaling applied to the shape drawn at the _i-th_  point."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **rotationFunction** : a custom javascript function. This function is called on each path point and is given the _i_ position of the point in the path and its _distance_ from the begining of the path. It must return a _rotation_ numeric value. This value will be the rotation applied to the shape drawn at the _i-th_  point."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **ribbonCloseArray** : _default false_, boolean. The underlying ribbon _closeArray_  parameter. This can be used to automatically close a path with right normals computation."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **ribbonClosePath** : _default false_, boolean. The underlying ribbon _closePath_  parameter. This can be used to automatically close a shape with right normals computation.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"*  **cap** : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **scene** : the current scene."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **updatable?** : if the mesh is updatable."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **sideOrientation** : the side orientation - _front, back_ or _double_."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"In this advanced method, the _scale_ and _rotation_ parameters are replaced by custom functions.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  **_scaleFunction_**   "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This javascript function will be called on each path point iteration when extruding. It will be passed two parameters : _i_ and _distance_.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **i** is the point position in the path, starting from zero for the first point."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **distance** is the current point distance from the begining of the path.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This custom function must return a _scale_ numeric value which will be applied to the shape on the _i-th_ point.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Example :"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var myScale = function(i, distance) {"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  var scale = 2 * Math.sin(i / 5);"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  return scale;"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"};"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is an example with an unclosed un-centered simple shape whose scale evolves linearly along the path : http://www.babylonjs-playground.com/#RF9W9#38    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Now if we use a sinus scaling function instead and as the shape isn't centered, we get interesting results : http://www.babylonjs-playground.com/#RF9W9#39    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"We can even emulate rotation by alternately scaling positive/negative : http://www.babylonjs-playground.com/#RF9W9#40    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  **_rotateFunction_**  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This javascript function will be called on each path point iteration when extruding. It will be passed two parameters : _i_ and _distance_.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **i** is the point position in the path, starting from zero for the first point."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **distance** is the current point distance from the begining of the path. "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This custom function must return a _rotation_ numeric value which will be applied to the shape on the _i-th_ point.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Example :"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var myRotation = function(i, distance) {"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  var rotation = distance / 20;"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  return rotation;"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"};"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Here is an example of constant scale and rotation evolving with the distance : http://www.babylonjs-playground.com/#RF9W9#41    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"You can set a non-linear rotation function of course, sinus here : http://www.babylonjs-playground.com/#RF9W9#42    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  **Fixed values**"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This advanced method needs two custom functions. But you may want to use a custom scale function with a fixed (or no) rotation function, for example. In this case, just pass a custom rotation function returning a fixed value :  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Example :  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"var noRotation = function(i, distance) {"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  return 0;"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"};"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"If you carefully read the code of this previous example, you can see in line 41 that the _scaleFunction_ returns the constant 1 value : http://www.babylonjs-playground.com/#RF9W9#41      "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"  **_ribbonCloseXXX_ parameters**"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"The extruded mesh is based on an underlying ribbon. When you extrude a shape, you actually make a particular ribbon.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"This means you can also set this ribbon _closeArray_ and _closePath_ parameter if you need to automatically close the extruded shape.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"NOTE : the _closeXXX_ names are the ribbon ones. Not the extruded shape ones.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"So it may be confusing because :  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **_ribbonCloseArray_** set to true will close your shape extrusion path,"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"* **_ribbonClosePath_** set to true will close your shape itself (if unclosed).  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Let's now do this unclosed, un-centered extruded shape : http://www.babylonjs-playground.com/#RF9W9#20  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"And this almost circular path : http://www.babylonjs-playground.com/#RF9W9#21  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Extrusion with constant scale and no rotation : http://www.babylonjs-playground.com/#RF9W9#43    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Now let's set the _ribbonCloseArray_ to true :http://www.babylonjs-playground.com/#RF9W9#44    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"As you can see, it closes the extrusion path. Let's set it back to false and let's set the _ribbonClosePath_ to true instead : http://www.babylonjs-playground.com/#RF9W9#45    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Now the shape is closed.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Both together : http://www.babylonjs-playground.com/#RF9W9#46    "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":" **Summary**  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"At last, the extrude custom function call would be, for example:  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```javascript"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"BABYLON.Mesh.ExtrudeShapeCustom(\"extruded\", shape, path, myScale, myRotation, false, true, scene)"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"```"},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"A shape is an array of successive Vector3. This means 2D or 3D shapes can be extruded as well.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"The shape is to be designed in the local coordinate system knowing that the z-axis will be the extrusion path axis.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Finally, shapes don't have to be centered in the local coordinate system.  "},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"A centered shape will be extruded symmetrically centered along the path axis. An un-centered shape will be extruded offset from the path axis.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push(new BABYLON.Vector3(x, y, z));"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  paths.push(path);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"http://www.babylonjs-playground.com/#1HSC2O#10    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Quick fun ?    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"multiply _y_ by _Math.sin(t)_ to make it wave : http://www.babylonjs-playground.com/#1HSC2O#11    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"or funnier : http://www.babylonjs-playground.com/#1HSC2O#12    "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"I couldn't stop playing ...  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"### Summary"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"An easy way to create math computed shapes is so :  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to choose a 2D math curve,"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to get its parametric equation,"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to fill an array with _Vector3_ computed with a simple _for_ loop iterating on the number of points wanted (set them in a 2D plane to start, with z = 0 for instance),"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to check your curve with _BABYLON.Mesh.CreateLines(\"name\", yourArray, scene)_,"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to derivate your first curve by varying _x_ or _y_ and iterating on _z_ since adding each derivated path into a _paths_ array,"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to check again with _BABYLON.Mesh.CreateLines(\"name\", yourArray, scene)_ on each _z_ iteration,"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* to finally build your ribbon with the _paths_ array. "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"## From Basic Shapes to Complex Ones"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The Ribbon is very versatile. So you can redo every BabylonJS basic shapes.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Why would you want to do this ?  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Well, you probably don't. There is no need to re-invent the wheel. But you could need to model your own shape which derivates from one of the basic shapes.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"The main rule should be :  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* if you need a basic shape as it stands, then use the provided BJS basic shapes."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* if you need a shape made up of many basic shapes, then use Constructive Solid Geometry or merge provided BJS basic shapes."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* if you need a computed shape having a symetry axis, then use the Tube mesh or the extrusion, which don't require many maths."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"* if you need something else, then use the Ribbon itself... and your maths skills."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"### Sphere"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's try here to redo a sphere and then to modify it into something different.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"As you've seen in the former part, you need to create many paths to build a ribbon. For a sphere, you can imagine that you stack many circles, each circle being a path.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"To create a circle, you just set points at _x = sin(angle)_ and _z = cos(angle)_ and give _angle_ some values between 0 and 2 x PI.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var pi2 = Math.PI * 2;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var step = pi2 / 60;       // we want 60 points"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var i = 0; i < pi2; i += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var x = radius * Math.sin(i);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var z = radius * Math.cos(i);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var y = 0;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  path.push( new BABYLON.Vector3(x, y, z) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"path.push(path[0]);       // to close the circle"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#1   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Now, you add circles along the y-axis, making the radius evolving with another angle _p_ varying from the sphere south pole -PI / 2 to its north pole +PI /2. These circles (path) are stored in an array called _paths_ :     "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var radius = 10;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var tes = 60;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var pi2 = Math.PI * 2;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var step = pi2 / tes;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var paths = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var p = -Math.PI / 2; p < Math.PI / 2; p += step / 2) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  for (var i = 0; i < pi2; i += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var x = radius * Math.sin(i) * Math.cos(p);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var z = radius * Math.cos(i) * Math.cos(p);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var y = radius * Math.sin(p);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push( new BABYLON.Vector3(x, y, z) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push(path[0]);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    paths.push(path);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's apply a ribbon to these paths : http://www.babylonjs-playground.com/#E6IX1#2   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You get (almost) a sphere.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"To get a nice full sphere, you need to complete the missing point at north pole and set the ribbon _closePath_ parameter to true instead of manually close each circle after the former iteration :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var lastPath = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var j = 0; j < pi2; j += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  lastPath.push( new BABYLON.Vector3(0, radius, 0) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"paths.push(lastPath);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var sphere = BABYLON.Mesh.CreateRibbon(\"sph\", paths, false, true ,  0, scene);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#3  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Pretty much maths and iterations o far to get a simple sphere, isn't it ?  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"This is why you should really use the BJS provided sphere if you only want a sphere !  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":" "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"But don't worry, all those efforts so far aren't vain. From now, let's the magic happens with only little changes ...   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Remember : the _for_ loop iterating on _p_ is for the south to north pole angle. What if you don't increment _p_ until PI / 2 but stop before, say at PI /2 - 1.5 :   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#4   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Quite easy. You just derivated the initial sphere into another shape you wouldn't have got another way.   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Now, you can keep the original pole angle limit PI / 2 but add a new behavior : if a certain angle limit is reached, then inverse the y radius around this limit.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var yRadius;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var limit = Math.PI / 2 - 1;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var p = -Math.PI / 2; p < Math.PI / 2; p += step / 2) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var path = [];"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  yRadius = p < limit ? Math.sin(p) : 2 * Math.sin(limit) - Math.sin(p) ;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  for (var i = 0; i < pi2; i += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var x = radius * Math.sin(i) * Math.cos(p);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var z = radius * Math.cos(i) * Math.cos(p);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    var y = radius * yRadius;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"    path.push( new BABYLON.Vector3(x, y, z) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  }"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  paths.push(path);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"} "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo :  http://www.babylonjs-playground.com/#E6IX1#5   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's change the initial _for_ loop limits now :  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var p = -Math.PI / 2 + 0.5; p < Math.PI / 2  - 0.5; p += step / 2) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#6  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Well, is this still a sphere ?   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Let's close the ribbon :"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"var sphere = BABYLON.Mesh.CreateRibbon(\"sph\", paths, true, true ,  0, scene);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#7   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Well, it's no longer a sphere, but a symetric shape you could probably have got in a simpler way with a Tube mesh or with CSG ... or not.  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Since you wrote the initial sphere maths code, you've added until now very few changes to get this derivated shape."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Too symetric, not enough, ok ? let's morph it once more so you get out the CSG or Tube way :  let's moderate _x_ with an extra _cosinus_ function"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var i = 0; i < pi2; i += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var x = radius * Math.sin(i) * Math.cos(p) * Math.cos(i / 6);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var z = radius * Math.cos(i) * Math.cos(p);"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // -------------------------------------------------------------"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Now, call the createScene function that you just finished creating"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      var scene = createScene();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Register a render loop to repeatedly render the scene"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      engine.runRenderLoop(function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         scene.render();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      });"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      // Watch for browser/canvas resize events"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      window.addEventListener(\"resize\", function () {"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"         engine.resize();"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"      });"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"   </script>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</body>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"</html>"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"```"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"## Moving On ##"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"From this point forward in the Basic Series tutorials, I will mostly talk about things that are contained in the createScene function (the part between the dashed lines). I will assume that you already know how to insert a createScene function into a Babylon.js HTML5 scene document (like the one above)."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Try to memorize this web page layout, and see how the createScene function is at the heart of it. After you have spent some time using the Babylon.js Playground, you will see how createScene() is portable, and can be easily copied and pasted TO and FROM the playground editor window. This will allow others to help you with problems, and will also allow you to help others with their problems."},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"## Next step ##"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"----"},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Now you are ready to go further and learn how to create more elements like spheres, cylinders, boxes, etc."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var ground = BABYLON.Mesh.CreateGround(\"ground\", 6, 6, 2, scene);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, width, depth, subdivs, scene"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Our [**Playground Demo Scene 01**](http://www.babylonjs-playground.com/?1) uses a CreateGround constructor... so you can see one in action by using the above link."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Creation of a Ground From HeightMap**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var ground = BABYLON.Mesh.CreateGroundFromHeightMap(\"ground\", \"heightmap.jpg\", 200, 200, 250, 0, 10, scene, false, successCallback);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, heightmapPath, width, depth, subdivs, minheight, maxheight, scene, updatable, successCallback"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"HeightMap grounds are easy, but we decided to create a separate tutorial so we could say more about this important Babylon.js feature. Please see our [**HeightMap Tutorial**](http://doc.babylonjs.com/page.php?p=22141) to learn all about heightMap grounds."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"* **Create of a Tiled Ground**"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Thanks to forum user Kostar111 for this handy Tiled Ground constructor. Here is the basic code needed to create a tiled ground."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```javascript"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var precision = {"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    \"w\" : 2,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    \"h\" : 2"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"};"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var subdivisions = {"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    'h' : 8,"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"    'w' : 8"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"};"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"var tiledGround = BABYLON.Mesh.CreateTiledGround(\"Tiled Ground\", -3, -3, 3, 3, subdivisions, precision, scene, false);"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"```"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Parameters are: name, xmin, zmin, xmax, zmax, subdivisions = the number of tiles. (subdivisions.w : in width; subdivisions.h: in height), precision = the number of subdivisions inside a tile. (precision.w : in width; precision.h: in height), scene, updatable."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"Kostar111 was also kind enough to give us a fine tutorial about how to use tiled grounds. [**Click right here**](http://makina-corpus.com/blog/metier/how-to-use-multimaterials-with-a-tiled-ground-in-babylonjs) to view it. At that link, Kostar111 thoroughly explains how the tiled ground works, and also provides some Babylon.js Playground scenes that nicely demonstrate some of its many uses."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"## Wrapping Up ##"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"And that’s it! Now you have seen all of our basic elements, and some ways to use them. Keep watching this area of the tutorial for new basic elements, as they are being added quite quickly. Feel free to imagine a few of your own basic element ideas, and present them on the forum. Help us make our list of basic elements grow, if you can."},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"## Next step ##"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"----"},{"src":"tutorials/02._Discover_Basic_Elements","name":"02. Discover Basic Elements","text":"We saw that we needed a bit of 'positioning' to keep our basic elements from sitting atop one another in the scene. Now let's learn more about positions (sometimes called translations) as well as about rotation and scaling. Ready? Sure you are! [**Click here for the next tutorial.**](http://doc.babylonjs.com/page.php?p=22041)"},{"src":"tutorials/04._Materials","name":"04. Materials","text":"Great, your scene is looking better than ever with those materials! Later we will see how to use advanced techniques with materials. But for now, we have to learn [**how to use cameras**](http://doc.babylonjs.com/page.php?p=22061)."},{"src":"tutorials/05._Cameras","name":"05. Cameras","text":"You have now learned how to use the two most-common cameras, and you have been introduced to all of our innovative 'unique purpose' cameras. You can control how you see your scene, you can choose your input and viewing devices, and you now know how to move cameras around. To give your scene a more realistic effect, we are now going to learn [**how to manage lights**](http://doc.babylonjs.com/page.php?p=22071). See you soon."},{"src":"tutorials/06._Lights","name":"06. Lights","text":"Guess what! The next tutorial... is about animation! [Click this and let's go!](http://doc.babylonjs.com/page.php?p=22081)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"// Adding animation to my torus animations collection"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"torus.animations.push(animationTorus);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"//Finally, launch animations on torus, from key 0 to key 120 with loop activated"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"scene.beginAnimation(torus, 0, 120, true);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You can play with bezier curve algorithm too, using the **BezierCurveEase(x1, y1, x2, y2)** function. "},{"src":"tutorials/07._Animations","name":"07. Animations","text":"For purpose, here is a good reference to create your curve algorithm : [http://cubic-bezier.com](http://cubic-bezier.com)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Here is a pretty cool implementation using the bezier curve algorithm :"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"![](http://www.dotmim.com/sitefiles/babylon/bezier.jpg)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```Javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var bezierEase = new BABYLON.BezierCurveEase(0.32, -0.73, 0.69, 1.59);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Finally, you can extend the **EasingFunction** base function to create your own easing function, like this :"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```Javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"var FunnyEase = (function (_super) {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;__extends(FunnyEase, _super);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;function FunnyEase() {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; _super.apply(this, arguments);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;}"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;FunnyEase.prototype.easeInCore = function (gradient) {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; // Here is the core method you should change to make your own Easing Function"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; // Gradient is the percent of value change"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; return Math.pow(Math.pow(gradient, 4), gradient);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;};"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;&nbsp; &nbsp;return FunnyEase;"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"})(BABYLON.EasingFunction);"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You will find a complete demonstration of the easing functions behaviors, in the playground : [**Easing function playground**](http://babylonjs-playground.azurewebsites.net/?20)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"**5 - Complex animation**"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"The complex animation lets you choose everything at each frame of the animation (each tick). The code computed at run time must be located in this function:"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```javascript"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"scene.registerBeforeRender(function () {"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"&nbsp;//Your code here"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"});"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"```"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"This function can be very useful for complex animation like games, where characters have to move depending on many parameters."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Don’t hesitate to combine all those types of animations. If well done, it’s very powerful."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Don't forget to [visit our API documentation](http://doc.babylonjs.com/) in order to learn more about the [**Babylon.js Animation**](http://doc.babylonjs.com/page.php?p=24916) class."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"You can view, edit, and get a zip of the code used in this tutorial... [**right here**](http://babylonjs-playground.azurewebsites.net/?7) ...at the Babylon.js Playground.&nbsp; The demo for the easing section is listed a few lines earlier."},{"src":"tutorials/07._Animations","name":"07. Animations","text":"## Next step"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```startPositionFunction = (worldMatrix: Matrix, positionToUpdate: Vector3)```: This function can be defined to specify initial position for every new particle. By default, this function is defined with the following code:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    startPositionFunction = (worldMatrix: Matrix, positionToUpdate: Vector3): void => {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randX = randomNumber(this.minEmitBox.x, this.maxEmitBox.x);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randY = randomNumber(this.minEmitBox.y, this.maxEmitBox.y);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        var randZ = randomNumber(this.minEmitBox.z, this.maxEmitBox.z);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    }"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"```customUpdateFunction: (particles: Particle[])```: This function can be defined to provide custom update for active particles. This function will be called instead of regular update (age, position, color, etc.). Do not forget that this function will be called on every frame so try to keep it simple and fast :). By default the following code is used:"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    updateFunction = (particles: Particle[]): void => {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"         for (var index = 0; index < particles.length; index++) {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               var particle = particles[index];"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               particle.age += this._scaledUpdateSpeed;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"            "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               if (particle.age >= particle.lifeTime) { // Recycle"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particles.splice(index, 1);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    this._stockParticles.push(particle);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    index--;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    continue;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               }"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               else {"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.colorStep.scaleToRef(this._scaledUpdateSpeed, this._scaledColorStep);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.color.addInPlace(this._scaledColorStep);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    if (particle.color.a < 0)"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                                 particle.color.a = 0;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.angle += particle.angularSpeed * this._scaledUpdateSpeed;"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.direction.scaleToRef(this._scaledUpdateSpeed, this._scaledDirection);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.position.addInPlace(this._scaledDirection);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    this.gravity.scaleToRef(this._scaledUpdateSpeed, this._scaledGravity);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"                    particle.direction.addInPlace(this._scaledGravity);"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"               }"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"         } "},{"src":"tutorials/12._Particles","name":"12. Particles","text":"    }"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"## Next step"},{"src":"tutorials/12._Particles","name":"12. Particles","text":"ParticleSystems are very powerful and versatile tools that can help bring realness and movement to your scenes. Don’t hesitate to use them as they are not resource-intensive."},{"src":"tutorials/13._Environment","name":"13. Environment","text":"You should have a beautiful scene now, but except from your 3D models, your world is pretty flat, and that’s a shame for your scene. So, in our next environment tutorial, we are going to transform your flat ground into beautiful mountains. To learn this, go [here!](http://doc.babylonjs.com/page.php?p=22141)."},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"These colors are BJS Color4-class values. The Color4 alpha values become active if we set _hasVertexAlpha = true_ : http://www.babylonjs-playground.com/#1V3CAT#6  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"We can even combine the vertex colors with a colored material, blue here :  http://www.babylonjs-playground.com/#1V3CAT#7  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"And finally we can also mix per-face colors with per-face textures, and/or mix either of those... with the material's standard colors. :  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```javascript"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  var options = {"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    width: 10,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    height: 3,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    depth: 5,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    faceUV: faceUV,"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"    faceColors : faceColors"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"  };"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"```"},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"Enjoy : http://www.babylonjs-playground.com/#1V3CAT#8  "},{"src":"tutorials/CreateBox_Per_Face_Textures_And_Colors","name":"CreateBox Per Face Textures And Colors","text":"No need for submaterials or submeshes, when seeking such simple things as box-side materials."},{"src":"tutorials/Parametric_Shapes","name":"Parametric Shapes","text":"Easy way to generate strange shapes : http://www.babylonjs-playground.com/#RF9W9#47   "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var y = radius * yRadius;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  path.push( new BABYLON.Vector3(x, y, z) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#8  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"You are now in the real Ribbon world !"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"Want more ? let's moderate _y_ with another _cosinus_ function and multiply _z_ by 2 (why ? why not !)."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```javascript"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"for (var i = 0; i < pi2; i += step ) {"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var x = radius * Math.sin(i) * Math.cos(p) * Math.cos(i / 6);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var z = radius * Math.cos(i) * Math.cos(p) * 2;"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  var y = radius * yRadius * Math.cos(i * 2);"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"  path.push( new BABYLON.Vector3(x, y, z) );"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"}"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"```"},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"demo : http://www.babylonjs-playground.com/#E6IX1#9  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"## Various paths concatenation  "},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"_make many different computed or manual pathArrays, then concatenate them_  "},{"src":"tutorials/01._Creating_Basic_Scene","name":"01. Creating Basic Scene","text":"Next in the Playpen Series - [**02-Basic elements**](http://doc.babylonjs.com/page.php?p=22011)"},{"src":"tutorials/07._Animations","name":"07. Animations","text":"Your scene is now becoming dynamic, and all your meshes can move in all directions! Feel free to try different animations on different objects, then come back and learn all about [**Sprites**](http://doc.babylonjs.com/page.php?p=22082)."},{"src":"tutorials/12._Particles","name":"12. Particles","text":"Stay with us, because we are going to learn a new, very interesting thing: [Configuring your environment](http://doc.babylonjs.com/page.php?p=22131)."},{"src":"tutorials/Ribbon_Tutorial","name":"Ribbon Tutorial","text":"_edition in progress_"}],"data_ptr":2592,"free_slots":[],"single_data_counter":7776}